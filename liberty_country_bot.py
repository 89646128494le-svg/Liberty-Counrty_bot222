from datetime import datetime, timedelta, timezone
import discord
from discord import ui
from discord.ext import commands, tasks
from discord import ui, ButtonStyle
import sqlite3
import random
import asyncio
import re
import os
import json
import math
from typing import Dict, List, Tuple, Optional, Union
from enum import Enum
import calendar
from discord.ui import View, Button, Modal, TextInput
from discord import Interaction, ButtonStyle, TextStyle
import time

# Поддержка старых вызовов с числовыми style=1/2 в TextInput: автоматически конвертируем в discord.TextStyle
# Это патч позволяет не править все модалки по файлу, где использовались integer-значения.
_original_textinput_init = discord.ui.TextInput.__init__
def _textinput_init(self, *args, **kwargs):
    if 'style' in kwargs and isinstance(kwargs['style'], int):
        try:
            # Попытка привести int к Enum TextStyle (1 -> short, 2 -> paragraph)
            kwargs['style'] = TextStyle(kwargs['style'])
        except Exception:
            pass
    return _original_textinput_init(self, *args, **kwargs)
discord.ui.TextInput.__init__ = _textinput_init

intents = discord.Intents.default()
intents.messages = True
intents.message_content = True
intents.members = True

bot = commands.Bot(command_prefix='!', intents=intents, help_command=None)
owner_id = [1056233936558227557, 1206304064128679958]  # список владельцев/админов

REAL_HOUR_TO_GAME_DAY = 1

DISCORD_TOKEN= "MTM5NDU5Nzg0MTU2MDY3MDMwMA.G3S42-.Rl47tuWvywqsecxdleeOgAeb6fo3p6INnv8clg"

# --- Доступные гражданские профессии ---
CIVIL_JOBS = [
    "Строитель",
    "Водитель автобуса",
    "Таксист",
    "Рыбак",
    "Медик",
    "Инженер",
    "Учитель",
    "Официант",
    "Программист"
]

# База знаний Уголовного Кодекса
CRIMINAL_CODE = {}
current_chapter = None
current_section = None

# Парсинг Уголовного Кодекса из приложенного файла
file_content = """Глава 1. Понятие преступления и покушение на преступление.​

1.1 Преступлением признается виновно совершенное общественно опасное деяние (противоправное, осознанное, волевое, действие или бездействие, нарушающее или создавшее реальную угрозу нарушения общественных отношений, охраняемых Уголовным законодательством), запрещенное настоящим Кодексом под угрозой наказания.

1.2 Не является преступлением действие (бездействие), хотя формально и содержащее признаки преступления, но в силу малозначительности не представля

1.3 Совокупностью преступлений признается совершение лицом двух или более преступлений, предусмотренных статьями настоящего Кодекса.
1.3.1 По приговору суда лицо может быть привлечено к уголовной ответственности по совокупности преступлений за каждое совершенное преступление по соответствующей статье настоящего Кодекса.
1.3.2 В случаях, не предусмотренных статьей 1.3.1 настоящего Кодекса, лицо несет наказание по той статье, которая имеет наибольший приоритет розыска.

1.4 Покушением на преступление признаются умышленные действия (бездействие) лица, непосредственно направленные на совершение преступления, если при этом преступление не было доведено до конца по не зависящим от этого лица обстоятельствам. Уголовная ответственность за покушение наступает по статье настоящего Кодекса, предусматривающей ответственность за оконченное преступление, со ссылкой на настоящую статью, но не может превышать половины предельного наказания за оконченное преступление.

Глава 2. Соучастие в преступлении.​

2.1 Соучастием в преступлении признается умышленное совместное участие двух или более лиц в совершении умышленного преступления.

2.2 Соучастниками преступления наряду с исполнителем признаются организатор, подстрекатель и пособник.

Исполнитель - лицо, непосредственно совершившее преступление, либо непосредственно участвовавшее в его совершении совместно с другими лицами (соисполнителями).
Организатор - организатором признается лицо, организовавшее совершение преступления или руководившее его исполнением.
Подстрекатель - лицо, склонившее другое лицо к совершению преступления путем уговора, подкупа, угрозы или другим способом.
Пособник - лицо, содействовавшее совершению преступления советами, указаниями, предоставлением информации, средств или орудий совершения преступления либо устранением препятствий.

2.3 Соучастники преступления вне зависимости от вида соучастия несут ответственность в равном объёме.

2.4 Преступление признается совершенным группой лиц, если в его совершении совместно участвовали два или более исполнителя.

2.5 Совершение преступления группой лиц влечет более строгое наказание.

Глава 3. Обстоятельства, исключающие преступность деяния.​

3.1 Не является преступлением причинение вреда посягающему лицу в состоянии необходимой обороны, при защите личности и прав обороняющегося или других лиц, если это посягательство было сопряжено с насилием, опасным для жизни обороняющегося или другого лица, либо с непосредственной угрозой применения такого насилия.

3.2 При причинении вреда в состоянии необходимой обороны не должны быть нарушены пределы необходимой обороны (умышленные действия, явно не соответствующие характеру и опасности посягательства).

3.3 Не является преступлением причинение вреда лицу, совершившему преступление, при его задержании для доставления органам власти, если иными средствами задержать такое лицо не представлялось возможным и при этом не было допущено превышения необходимых для этого мер (когда лицу без необходимости причиняется явно чрезмерный, не вызываемый обстановкой вред).

3.4 Не является преступлением причинение вреда в состоянии крайней необходимости, то есть для устранения опасности, непосредственно угрожающей личности и правам данного лица или иных лиц, если эта опасность не могла быть устранена иными средствами и при этом не было допущено превышения пределов крайней необходимости (явно не соответствующего характеру и степени угрожавшей опасности и обстоятельствам).

3.5 Не является преступлением причинение вреда при обоснованном риске для достижения общественно полезной цели, если указанная цель не могла быть достигнута не связанными с риском действиями (бездействием). Риск не признается обоснованным, если он заведомо был сопряжен с угрозой для жизни многих людей.

3.6 Не является преступлением причинение вреда охраняемым интересам лицом, действующим во исполнение обязательных для него приказа или распоряжения. Уголовную ответственность за причинение такого вреда несет лицо, отдавшее незаконные приказ или распоряжение. (Лицо, совершившее преступление во исполнение заведомо незаконных приказа или распоряжения, несет уголовную ответственность на общих основаниях. Неисполнение заведомо незаконных приказа или распоряжения исключает уголовную ответственность).

3.7 Не является преступлением деяние, совершенное неумышленно, то есть по неосторожности, кроме случаев, когда иное предусмотрено соответствующими статьями Особенной части настоящего Кодекса.

3.7.1 Деяние признается умышленным, если лицо осознавало общественную опасность деяния и желало наступления опасных последствий или относилось к их наступлению безразлично.

3.7.2 Деяние признается неумышленно, если лицо предвидело возможность наступления общественно опасных последствий деяния, но без достаточных к тому оснований самонадеянно рассчитывало на предотвращение этих последствий, а равно не предвидело возможности наступления общественно опасных последствий деяния, хотя при необходимой внимательности и предусмотрительности должно было и могло предвидеть эти последствия.

3.8 Закон, устраняющий преступность деяния, который смягчает наказание и улучшает положения лица, совершившего преступление, имеет обратную силу, то есть распространяется на лиц, совершивших соответствующие деяния до вступления такого закона в силу.

Раздел 2. Назначение наказания и освобождение от уголовной ответственности и наказания.

Глава 4. Назначение наказания. Виды и цели наказания.​

4.1 Лицу, признанному виновным в совершении преступления, назначается справедливое наказание в пределах, предусмотренных соответствующей статьей Особенной части настоящего Кодекса, и с учетом положений Общей части настоящего Кодекса.

4.2 При назначении наказания учитываются характер и степень общественной опасности преступления и личность виновного, в том числе обстоятельства, смягчающие и отягчающие наказание.

4.3 Смягчающими обстоятельствами признаются:
4.3.1 Совершение преступления в результате физического или психического принуждения либо в силу материальной, служебной или иной зависимости.
4.3.2 Совершение преступления при нарушении условий правомерности необходимой обороны, задержания лица, совершившего преступление, крайней необходимости, обоснованного риска, исполнения приказа или распоряжения.
4.3.3 Противоправность или аморальность поведения потерпевшего, явившегося поводом для преступления.
явка с повинной, активное способствование раскрытию и расследованию преступления, изобличению и уголовному преследованию других соучастников преступления.

4.3.4 Оказание медицинской и иной помощи потерпевшему после совершения преступления, добровольное возмещение имущественного ущерба и морального вреда, причиненных в результате преступления, иные действия, направленные на заглаживание вреда, причиненного потерпевшему.
4.3.5 Иные обстоятельства.

4.4 Отягчающими обстоятельствами признаются:
4.4.1 Совершение преступления в составе группы лиц.
4.4.2 Совершение преступления по мотивам политической, идеологической, расовой, национальной или религиозной ненависти, или вражды либо по мотивам ненависти или вражды в отношении какой-либо социальной группы.

4.4.3 Совершение преступления из мести за правомерные действия других лиц, а также с целью скрыть другое преступление или облегчить его совершение.
4.4.4 Совершение преступления в отношении лица или его близких в связи с осуществлением данным лицом служебной деятельности или выполнением общественного долга.
4.4.5 Совершение преступления с особой жестокостью, садизмом, издевательством, а также мучениями для потерпевшего.
4.4.6 Совершение преступления с использованием доверия, оказанного виновному в силу его служебного положения или договора.
4.4.7 Совершение преступления с использованием форменной одежды или документов представителя власти.
4.4.8 Многократное умышленное совершение преступления, а равно рецидив.

4.5 Наказание является мерой государственного принуждения, назначаемая по приговору суда и иным решениям, описанных настоящим Кодексом. Наказание применяется к лицу, признанному виновным в совершении преступления, и заключается в лишении или ограничении прав и свобод по соответствующим положениям статьей настоящего Кодекса.

4.6Назначение наказание осуществляется введением в законную силу соответствующего судебного решения.
4.6.1 Время содержания лица под стражей до судебного разбирательства учитывается при вынесении приговора.
4.6.2 Штрафы, предусмотренные статьями настоящего Кодекса, применяются исключительно в судебном порядке либо прокуратурой.
.
4.7 В результате судебного процесса по уголовному делу могут быть назначены следующие виды наказаний:

Судебный штраф. (Сумма регулируется на усмотрение Суда)
Лишение права занимать определенные должности или заниматься определенной деятельностью
Лишение права занимать любую должность в государственной организации (Черный список)
Увольнение с государственной или военной службы, в том числе с лишением всех званий, наград и привилегий
Лишение свободы на определенный срок
Пожизненное лишение свободы
Компенсация и возмещение пострадавшему юридическому или физическому лицу. (Сумма регулируется на усмотрение Суда)
Конфискация имущества
Принудительное психиатрическое лечение
Исправительные работы
4.7.1 Мера наказания указанная в статьях, может регулироваться вердиктом Суда. Виды наказания указаны в статье 4.7 настоящего Кодекса.
4.7.2 В результате расследования правоохранительными органами по уголовному делу может быть назначено только лишение свободы на определенный срок (КПЗ).
4.7.3 Если органом, проводившим расследование, не был установлен запрет выхода под залог в соответствии с Процессуальным кодексом Штата Сан-Андреас, лицу, отбывающему наказание, лишение свободы может быть заменено на залог, определяемый в соответствии с положениями соответствующих статей настоящего Кодекса.

4.8 Наказание за совершение деяния, нарушающего любую из статей настоящего кодекса, не может превышать меры, которая предусмотрена нарушенной статьей.

4.9 В случае совершения лицом особо тяжкого преступления, срок лишения свободы может превышать установленный настоящим Законом вплоть до пожизненного лишения свободы.
4.9.1 В момент расследования правоохранительными органами или составление уголовного дела, лицо совершившее нарушение, может быть лишен свободы (КПЗ) до конца судебного или досудебного разбирательства.

4.10 Виды преступлений бывают: (F) Федеральными, (R) Региональными.

4.10.1 Федеральное преступление → к этому виду преступления относятся деяния с обозначением (F). Такие преступления обязаны разбирать представители федеральных структур.
4.10.1.1 Если задержание такого преступника проводят органы правоохранительной власти, они обязаны довести задержание до пункта 2.1.7 включительно, согласно Главе 2, статье 2 "Порядок задержания" Процессуального Кодекса, после чего сообщить по рации департамента с запросом о передаче задержанного Федеральной структуре.
4.10.1.2 В случае, если в течении 3-х минут ответа от Федеральной структуры не поступает, то сотрудник правоохранительных органов обязан продолжить процесс задержания с последующим помещением в камеру предварительного заключения (КПЗ).
4.10.1.3 Федеральная структура имеет право дистанционно отреагировать на запрос и одобрить процесс задержания без присутствия на его месте проведения.

4.10.2 Региональное преступление → к этому виду преступления относится деяния с обозначением (R). Такие преступления обязаны разбирать все уполномоченные правоохранительные органы.

Глава 5. Освобождение от уголовной ответственности и наказания.​

5.1 Лицо, впервые совершившее преступление, предусмотренное статьями: предельный срок наказания за которое не превышает 4 лет лишения свободы,, может быть освобождено прокуратурой от уголовной ответственности, если оно примирилось с потерпевшим и загладило причиненный потерпевшему вред.

5.2 Лицо, впервые совершившее преступление может быть освобождено решением суда или постановлением прокуратуры от уголовной ответственности с назначением штрафа, а также занесением в DataBase, с указанием освобождения от уголовной ответственности, если такое лицо нарушило не более одного пункта из уголовных статей.
Примечание: такие статьи, как 6.2 УК, 6.3 УК, 6.4 УК, 12.1 УК, 12.12 УК, 12.13 УК, 14.1 УК, 14.2 УК, 16.2 УК, 16.17 УК, 17.1 УК являются особо тяжкими, освобождение по данным статьям невозможно.

5.3 Лицо освобождается от уголовной ответственности, если со дня совершения преступления прошло 20 дней.
5.3.1 В случае, если за данный период времени не были применены санкции по отношению к нарушителю.
5.3.2 Сроки давности по уголовному преступлению приостанавливают свое течение на время проведения судебного разбирательства или следствия.

5.4 К лицам, совершившим преступления, предусмотренные главой 14, статьями 6.2, 6.3, 6.5, 8.2, 12.1 - 12.5, 12.13, 15.1, 16.2, 17.1 настоящего Кодекса, сроки давности не применяются.
5.5 Лицо, добровольно сдавшее предметы, указанные в статьях 12.8, 12.8.1, 13.1, 13.2, 14.4 настоящего Кодекса, освобождается от уголовной ответственности по соответствующей статье. Не может признаваться добровольной сдачей предметов их изъятие при задержании лица, а также при производстве любых оперативных и/или следственных действий.

5.6Найденные наркотические вещества в ходе обыска сотрудниками гос. структуры в количестве до 3 грамм (включительно), изымаются без привлечения к уголовной ответственности.
5.6.1 В случае нахождения у гражданина более 3 грамм наркотических веществ, несёт за собой уголовную ответственность статьи 13.1.
5.6.2 В случае нахождения у гражданина более 3 грамм "Семена Green", несёт за собой уголовную ответственность статьи 13.1.
5.6.2.1 Найденные вещества "Семена Green" в ходе обыска сотрудниками гос. структуры в количество до 3 грамм (включительно), являются легальными без привлечения к уголовной ответственности.

5.7 Один "Куст Green" приравнивается к 5-ти граммам наркотических веществ.
5.7.1 В случае нахождения у гражданина до двух кустов (включительно), изымаются без привлечения к уголовной ответственности.

5.8 Выход под залог осуществляют только лицензированные адвокаты. Содействие в выходе под залог имеют лица, которые были признаны членами коллегии адвокатов.
5.9 Стоимость выхода под залог регламентирует настоящий Кодекс и определяется согласно приоритету розыска.

5.9.1 Приоритет розыска 1 - стоимость выхода под залог составляет - 8.000$
5.9.2 Приоритет розыска 2 - стоимость выхода под залог составляет - 10.000$
5.9.3 Приоритет розыска 3 - стоимость выхода под залог составляет - 12.000$
5.9.4 Приоритет розыска 4 - стоимость выхода под залог составляет - 15.000$
5.9.5 Приоритет розыска 5 - стоимость выхода под залог составляет - 20.000$
.
5.10 Члены коллегии адвокатов обязаны вести учёт поступлений денежных средств за выход под залог.
5.10.1 Залог, выплаченный заключённым, рассматривается в отношении 80/20, где 80% является оплатой услуг адвоката, который выпустил под залог заключенного, а 20% - выдается сотруднику правоохранительных органов.
Примечание: Выпустить под залог имеет право только тот сотрудник правоохранительных органов, который непосредственно заполнял Database с данными задержанного (приоритетно), либо в случае отсутствия данного сотрудника - сотрудник являвшийся субъектом задержания и чьи данные фигурируют в Database задержанного.
5.10.2 Офицеру полиции запрещено назначать/повышать размер залога.
5.10.3 Офицер который содействует адвокату, обязан указать свои служебные данные для оформления документации.

5.11 Причины, по которым лицу отказывается в праве выхода под залог:
5.11.1 Задержанный заключен по одной или нескольким статьям Уголовного кодекса Liberty State из приведенного перечня: 6.3 УК, 6.4 УК, 12.1 УК, 12.12 УК, 12.13 УК, 14.1 УК, 14.2 УК, 14.2.1 УК, 16.2 УК, 16.15 УК, 16.17 УК, 17.1 УК.
5.11.2 Задержанный является рецидивистом. Рецидивом преступлений признается совершение умышленно
5.11.4 Задержанный отказывается сотрудничать со следствием.
5.11.5 Задержанный осужден более чем по трём статьям.

Основная часть

Раздел 3. Преступления против личности.


Глава 6. Преступления против жизни и здоровья.​

6.1 (R) Умышленное нанесение телесных повреждений.
Приоритет розыска - 2
Наказание: От 2 лет лишения свободы.

6.1.1 (R) Умышленное нанесение тяжких телесных повреждений.
Приоритет розыска - 3
Наказание: До 6 лет, выход под залог разрешён.

6.2 (F/R) Убийство, то есть умышленное причинение смерти другому человеку.
Приоритет розыска - 4
Наказание: 8 лет лишения свободы.

6.3 (F) Тяжкое убийство, то есть убийство двух или более лиц, равно как убийство близких жертвы в связи с осуществлением данным лицом служебной деятельности.
Приоритет розыска - 5
Наказание: От 10 лет лишения свобода.

6.
Приоритет розыска - 5
Наказание: От 30 лет лишения свободы.

6.5 (R) Причинение тяжкого вреда здоровью по неосторожности.
Приоритет розыска - 2
Наказание: До 4 лет лишения свободы.

6.6 (R) Причинение смерти по неосторожности.
Приоритет розыска - 3
Наказание: До 6 лет лишения свободы.

6.7 (F/R) Угроза расправой (прямая или косвенная) должностному (сотруднику гос. структур) лицу а равно их близким.
Приоритет розыска - 3
Наказание: До 3 лет лишения свободы.

6.8 (F/R) Угрозы с целью запугать человека.
Приоритет розыска - 2
Наказание: До 2 лет лишения свободы.

6.9 (R) Умышленное нанесение телесных повреждений животному.
Приоритет розыска - 2
Наказание: От 2 лет до 6 лет лишения свободы.

Глава 7. Преступления против свободы, чести и достоинства личности.​

7.1 (F) Похищение человека.
Приоритет розыска - 5
Наказание: От 40 лет лишения свободы.

7.2 (R) Клевета, содержащаяся в публичном выступлении, средствах массовой информации либо с использованием своего служебного положения.
Приоритет розыска - 2
Наказание: До 6 лет лишения свободы.

7.3 (R) Клевета, соединенная с обвинением лица в совершении преступления.
Приоритет розыска - 2
Наказание: До 6 лет лишения свободы.

7.4 (R) Нарушение против личности, деловой репутации и оскорбления сотрудниками представительства Средств Массовой информации, равно нарушение законодательства об журналистской деятельности.
Приоритет розыска - 4
Наказание: До 4 лет лишения свободы, без права осуществлять журналистскую деятельность.

7.5 (R) Действия, направленные на возбуждение ненависти либо вражды по отношению к человеку или группе лиц по признаку от их пола, расы, национальности, языка, религии, происхождения, имущественного и должностного положения, место жительства, убеждений, принадлежности к общественным объединениям или каким-либо социальным группам.
Приоритет розыска - 2
Наказание: До 6 лет лишения свободы.

7.6 (R) Действия, направленные на возбуждение ненависти либо вражды по отношению к человеку или группе лиц по признаку от их пола, расы, национальности, языка, религии, происхождения, имущественного и должностного положения, место жительства, убеждений, принадлежности к общественным объединениям или каким-либо социальным группам, совершенные представителем власти.
Приоритет розыска - 4
Наказание: До 10 лет лишения свободы.

Глава 8. Преступления против половой неприкосновенности и половой свободы личности.​

8.1 (R) Насильственные действия сексуального характера, то есть половое сношение с применением насилия или с угрозой его применения к потерпевшей (потерпевшему) или к другим лицам либо с использованием беспомощного состояния потерпевшей (потерпевшему).
Приоритет розыска 3
Наказание: До 8 лет лишения свободы.

8.2 (F) Насильственные действия сексуального характера повлекшее по неосторожности причинение тяжкого вреда здоровью или смерть потерпевшего (потерпевшей).
Приоритет розыска 5
Наказание: До 8 лет лишения свободы.

8.3 (R) Насильственное принуждение лица к половому сношению или совершению иных действий сексуального характера путем шантажа, угрозы уничтожением, повреждением или изъятием имущества либо с использованием материальной или иной зависимости потерпевшего (потерпевшей).
Приоритет розыска 2
Наказание: До 2 лет лишения свободы.

Глава 9. Преступления против конституционных прав и свобод человека и гражданина.​

9.1 (F) Незаконное собирание или распространение сведений о частной жизни лица, составляющих его личную или семейную тайну, без его согласия либо распространение этих сведений в публичном выступлении, публичном произведении или средствах массовой информации, в том числе с использованием своего служебного положения.
Приоритет розыска 1
Наказание: До 2 лет лишения свободы.

9.2 (R) Незаконное проникновение в жилище и частную территорию, совершенное против воли владельца, в том числе с использованием своего служебного положения.
Приоритет розыска 2
Наказание: До 4 лет лишения свободы.

9.3 (F) Воспрепятствование свободному осуществлению гражданином своих избирательных прав, в том числе соединенные с подкупом, обманом, принуждением, применением насилия либо с угрозой его применения.
Приоритет розыска 1
Наказание: До 6 лет лишения свободы.

9.4 (R) Воспрепятствование законной профессиональной деятельности журналистов путем принуждения их к распространению либо к отказу от распространения информации.
Приоритет розыска 1
Наказание: До 4 лет лишения свободы.

9.5 (R) Воспрепятствование законной профессиональной деятельности журналистов путем незаконного ограничения права поиска, получения, передачи, производства и распространения информации любым законным способом.
Приоритет розыска 1
Наказание: До 4 лет лишения свободы.

9.6 (R) Необоснованный отказ от предоставления медицинских услуг лицами, уполномоченными на осуществления таких действий, если это повлекло за собой причинение вреда больному. Необоснованный отказ от предоставления услуг правоохранительных органов.
Приоритет розыска 2
Наказание: До 5 лет лишения свободы."""

# Парсинг файла
lines = file_content.split('\n')
for line in lines:
    # Обработка глав
    chapter_match = re.match(r'Глава (\d+)\. (.+)', line)
    if chapter_match:
        chapter_num = chapter_match.group(1)
        chapter_title = chapter_match.group(2)
        CRIMINAL_CODE[chapter_num] = {
            'title': chapter_title,
            'articles': {}
        }
        current_chapter = chapter_num
        current_section = None
        continue

    # Обработка разделов
    section_match = re.match(r'Раздел (\d+)\. (.+)', line)
    if section_match:
        section_num = section_match.group(1)
        section_title = section_match.group(2)
        if current_chapter:
            if 'sections' not in CRIMINAL_CODE[current_chapter]:
                CRIMINAL_CODE[current_chapter]['sections'] = {}
            CRIMINAL_CODE[current_chapter]['sections'][section_num] = {
                'title': section_title,
                'articles': {}
            }
            current_section = section_num
        continue

    # Обработка статей
    article_match = re.match(r'(\d+\.\d+(?:\.\d+)?)\s+\(?(F|R|F/R)?\)?\s*(.+)', line)
    if article_match:
        article_num = article_match.group(1)
        article_type = article_match.group(2) if article_match.group(2) else ''
        article_title = article_match.group(3).strip()

        # Поиск описания статьи
        description = []
        next_line_index = lines.index(line) + 1
        while next_line_index < len(lines):
            next_line = lines[next_line_index]
            if re.match(r'\d+\.\d+', next_line) or re.match(r'Глава|Раздел', next_line):
                break
            if next_line.strip() and not next_line.startswith('Приоритет') and not next_line.startswith('Наказание'):
                description.append(next_line.strip())
            next_line_index += 1

        article_data = {
            'type': article_type,
            'title': article_title,
            'description': '\n'.join(description),
            'priority': None,
            'penalty': None
        }

        # Добавление в структуру
        if current_section and current_chapter:
            CRIMINAL_CODE[current_chapter]['sections'][current_section]['articles'][article_num] = article_data
        elif current_chapter:
            CRIMINAL_CODE[current_chapter]['articles'][article_num] = article_data
        continue

    # Обработка приоритета и наказания
    if 'Приоритет розыска' in line:
        priority_match = re.search(r'Приоритет розыска\s*-\s*(\d+)', line)
        if priority_match:
            if current_section and current_chapter and article_num:
                CRIMINAL_CODE[current_chapter]['sections'][current_section]['articles'][article_num]['priority'] = int(
                    priority_match.group(1))
            elif current_chapter and article_num:
                CRIMINAL_CODE[current_chapter]['articles'][article_num]['priority'] = int(priority_match.group(1))

    if 'Наказание:' in line:
        penalty_text = line.replace('Наказание:', '').strip()
        if current_section and current_chapter and article_num:
            CRIMINAL_CODE[current_chapter]['sections'][current_section]['articles'][article_num][
                'penalty'] = penalty_text
        elif current_chapter and article_num:
            CRIMINAL_CODE[current_chapter]['articles'][article_num]['penalty'] = penalty_text


# Функция для поиска статей в УК
def search_criminal_code(query):
    results = []
    query_lower = query.lower()

    # Поиск по всем главам, разделам и статьям
    for chapter_num, chapter_data in CRIMINAL_CODE.items():
        # Проверка соответствия главы
        if query_lower in chapter_num.lower() or query_lower in chapter_data['title'].lower():
            results.append({
                'type': 'chapter',
                'number': chapter_num,
                'title': chapter_data['title'],
                'content': chapter_data
            })

        # Поиск по разделам главы
        if 'sections' in chapter_data:
            for section_num, section_data in chapter_data['sections'].items():
                if query_lower in section_num.lower() or query_lower in section_data['title'].lower():
                    results.append({
                        'type': 'section',
                        'number': f"{chapter_num}.{section_num}",
                        'title': section_data['title'],
                        'content': section_data
                    })

        # Поиск по статьям
        if 'articles' in chapter_data:
            for article_num, article_data in chapter_data['articles'].items():
                if (query_lower in article_num.lower() or
                        query_lower in article_data['title'].lower() or
                        (article_data['description'] and query_lower in article_data['description'].lower())):
                    results.append({
                        'type': 'article',
                        'number': f"{chapter_num}.{article_num}",
                        'title': article_data['title'],
                        'content': article_data
                    })

    return results


# Инициализация базы данных
import sqlite3

# ===== ДОПОЛНИТЕЛЬНЫЕ ФУНКЦИИ =====

def update_field(discord_id, field, value):
    """Обновить поле в базе данных для гражданина"""
    conn = sqlite3.connect('liberty_country.db')
    c = conn.cursor()
    c.execute(f"UPDATE citizens SET {field}=? WHERE discord_id=?", (value, str(discord_id)))
    conn.commit()
    conn.close()

def add_house(discord_id, address):
    """Выдать дом гражданину"""
    conn = sqlite3.connect('liberty_country.db')
    conn.row_factory = sqlite3.Row
    c = conn.cursor()
    c.execute("SELECT id FROM citizens WHERE discord_id=?", (str(discord_id),))
    citizen = c.fetchone()
    if not citizen:
        conn.close()
        return False
    c.execute("""
        INSERT OR REPLACE INTO houses (address, owner_id, status, district, price, rent)
        VALUES (?, ?, 'owned', 'Custom', 0, 0)
    """, (address, citizen['id']))
    c.execute("UPDATE citizens SET residence=? WHERE id=?", (address, citizen['id']))
    conn.commit()
    conn.close()
    return True

def add_business(discord_id, name, income):
    """Выдать бизнес гражданину"""
    conn = sqlite3.connect('liberty_country.db')
    conn.row_factory = sqlite3.Row
    c = conn.cursor()
    c.execute("SELECT id FROM citizens WHERE discord_id=?", (str(discord_id),))
    citizen = c.fetchone()
    if not citizen:
        conn.close()
        return False
    c.execute("""
        INSERT INTO businesses (name, owner_id, type, income, employee_count)
        VALUES (?, ?, 'Custom', ?, 0)
    """, (name, citizen['id'], income))
    conn.commit()
    conn.close()
    return True

def remove_business(discord_id):
    """Изъять все бизнесы у гражданина"""
    conn = sqlite3.connect('liberty_country.db')
    conn.row_factory = sqlite3.Row
    c = conn.cursor()
    c.execute("SELECT id FROM citizens WHERE discord_id=?", (str(discord_id),))
    citizen = c.fetchone()
    if not citizen:
        conn.close()
        return False
    c.execute("DELETE FROM businesses WHERE owner_id=?", (citizen['id'],))
    conn.commit()
    conn.close()
    return True

def add_license(discord_id, license_name):
    """Выдать лицензию гражданину"""
    conn = sqlite3.connect('liberty_country.db')
    c = conn.cursor()
    c.execute("SELECT licenses FROM citizens WHERE discord_id=?", (str(discord_id),))
    result = c.fetchone()
    if not result:
        conn.close()
        return False
    current_licenses = result[0] if result[0] else ""
    licenses_list = [lic.strip() for lic in current_licenses.split(',') if lic.strip()]
    if license_name not in licenses_list:
        licenses_list.append(license_name)
    new_licenses = ','.join(licenses_list)
    c.execute("UPDATE citizens SET licenses=? WHERE discord_id=?", (new_licenses, str(discord_id)))
    conn.commit()
    conn.close()
    return True

def remove_license(discord_id, license_name):
    """Изъять лицензию у гражданина"""
    conn = sqlite3.connect('liberty_country.db')
    c = conn.cursor()
    c.execute("SELECT licenses FROM citizens WHERE discord_id=?", (str(discord_id),))
    result = c.fetchone()
    if not result:
        conn.close()
        return False
    current_licenses = result[0] if result[0] else ""
    licenses_list = [lic.strip() for lic in current_licenses.split(',') if lic.strip()]
    if license_name in licenses_list:
        licenses_list.remove(license_name)
    new_licenses = ','.join(licenses_list)
    c.execute("UPDATE citizens SET licenses=? WHERE discord_id=?", (new_licenses, str(discord_id)))
    conn.commit()
    conn.close()
    return True

def log_transaction(discord_id, transaction_type, amount):
    """Логировать банковскую транзакцию"""
    conn = sqlite3.connect('liberty_country.db')
    c = conn.cursor()
    timestamp = datetime.now(timezone.utc).strftime('%Y-%m-%d %H:%M:%S')
    try:
        c.execute("""
            INSERT INTO bank_transactions (discord_id, type, amount, timestamp)
            VALUES (?, ?, ?, ?)
        """, (str(discord_id), transaction_type, amount, timestamp))
        conn.commit()
    except:
        pass
    conn.close()

def change_name(discord_id, new_first_name, new_last_name):
    """Изменить имя гражданина"""
    conn = sqlite3.connect('liberty_country.db')
    c = conn.cursor()
    timestamp = datetime.now(timezone.utc).strftime('%Y-%m-%d %H:%M:%S')
    c.execute("SELECT first_name, last_name FROM citizens WHERE discord_id=?", (str(discord_id),))
    old_data = c.fetchone()
    if old_data:
        old_first, old_last = old_data
        try:
            c.execute("""
                INSERT INTO name_changes (discord_id, old_first_name, old_last_name, 
                                         new_first_name, new_last_name, change_date)
                VALUES (?, ?, ?, ?, ?, ?)
            """, (str(discord_id), old_first, old_last, new_first_name, new_last_name, timestamp))
        except:
            pass
        c.execute("UPDATE citizens SET first_name=?, last_name=? WHERE discord_id=?", 
                 (new_first_name, new_last_name, str(discord_id)))
    conn.commit()
    conn.close()



def init_db():
    conn = sqlite3.connect('liberty_country.db')
    c = conn.cursor()

    # --- Основная таблица граждан ---
    c.execute('''
        CREATE TABLE IF NOT EXISTS citizens (
            id INTEGER PRIMARY KEY AUTOINCREMENT,
            user_id TEXT UNIQUE,
            discord_id TEXT,
            first_name TEXT,
            last_name TEXT,
            age INTEGER DEFAULT 0,
            bio TEXT DEFAULT '',
            is_usa_born BOOLEAN DEFAULT 1,
            blocked_government BOOLEAN DEFAULT 0,
            birth_date TEXT,
            birth_place TEXT,
            residence TEXT DEFAULT 'Отель',
            citizenship_date TEXT,
            passport_issued BOOLEAN DEFAULT 0,
            medical_book BOOLEAN DEFAULT 0,
            licenses TEXT DEFAULT '',
            job TEXT DEFAULT 'безработный',
            business TEXT,
            property TEXT,
            cash INTEGER DEFAULT 100,
            bank INTEGER DEFAULT 0,
            work_count INTEGER DEFAULT 0,
            last_work_real_time FLOAT DEFAULT 0,
            credit_score INTEGER DEFAULT 100,
            hotel_until TEXT
        )
    ''')

    # --- Проверка и добавление недостающих столбцов (если нужно) ---
    existing_columns = [col[1] for col in c.execute("PRAGMA table_info(citizens)").fetchall()]
    columns_to_add = {
        "user_id": "TEXT UNIQUE",
        "bio": "TEXT DEFAULT ''",
        "blocked_government": "BOOLEAN DEFAULT 0",
        "hotel_until": "TEXT"
    }
    for col_name, col_type in columns_to_add.items():
        if col_name not in existing_columns:
            try:
                c.execute(f"ALTER TABLE citizens ADD COLUMN {col_name} {col_type}")
            except:
                pass

    # --- Остальные таблицы ---
    c.execute('''
        CREATE TABLE IF NOT EXISTS bans (
            id INTEGER PRIMARY KEY AUTOINCREMENT,
            discord_id TEXT UNIQUE,
            reason TEXT,
            banned_by TEXT,
            ban_date TEXT
        )
    ''')

    c.execute('''
        CREATE TABLE IF NOT EXISTS vehicles (
            id INTEGER PRIMARY KEY AUTOINCREMENT,
            plate TEXT,
            owner_id INTEGER,
            model TEXT,
            color TEXT,
            year INTEGER,
            type TEXT,
            tuning TEXT,
            notes TEXT,
            stolen BOOLEAN DEFAULT 0,
            FOREIGN KEY (owner_id) REFERENCES citizens (id)
        )
    ''')

    c.execute('''
        CREATE TABLE IF NOT EXISTS weapons (
            id INTEGER PRIMARY KEY AUTOINCREMENT,
            owner_id INTEGER,
            type TEXT,
            serial TEXT,
            license_required TEXT,
            purchase_date TEXT,
            FOREIGN KEY (owner_id) REFERENCES citizens (id)
        )
    ''')

    c.execute('''
        CREATE TABLE IF NOT EXISTS loans (
            id INTEGER PRIMARY KEY AUTOINCREMENT,
            citizen_id INTEGER,
            amount INTEGER,
            interest_rate FLOAT,
            taken_date TEXT,
            due_date TEXT,
            paid_amount INTEGER DEFAULT 0,
            status TEXT DEFAULT 'active',
            FOREIGN KEY (citizen_id) REFERENCES citizens (id)
        )
    ''')

    c.execute('''
        CREATE TABLE IF NOT EXISTS name_changes (
            id INTEGER PRIMARY KEY AUTOINCREMENT,
            citizen_id INTEGER,
            old_first_name TEXT,
            old_last_name TEXT,
            new_first_name TEXT,
            new_last_name TEXT,
            date TEXT,
            cost INTEGER,
            FOREIGN KEY (citizen_id) REFERENCES citizens (id)
        )
    ''')

    c.execute('''
        CREATE TABLE IF NOT EXISTS bank_transactions (
            id INTEGER PRIMARY KEY AUTOINCREMENT,
            citizen_id INTEGER,
            type TEXT,
            amount INTEGER,
            related_id INTEGER,
            timestamp TEXT,
            FOREIGN KEY (citizen_id) REFERENCES citizens (id)
        )
    ''')

    c.execute('''
        CREATE TABLE IF NOT EXISTS job_applications (
            id INTEGER PRIMARY KEY AUTOINCREMENT,
            citizen_id INTEGER,
            faction TEXT,
            status TEXT DEFAULT 'pending',
            application_date TEXT,
            FOREIGN KEY (citizen_id) REFERENCES citizens (id)
        )
    ''')

    c.execute('''
        CREATE TABLE IF NOT EXISTS warrants (
            id INTEGER PRIMARY KEY AUTOINCREMENT,
            citizen_id INTEGER,
            reason TEXT,
            officer_id INTEGER,
            issue_date TEXT,
            level INTEGER DEFAULT 1,
            status TEXT DEFAULT 'active',
            description TEXT,
            FOREIGN KEY (citizen_id) REFERENCES citizens (id)
        )
    ''')

    c.execute('''
        CREATE TABLE IF NOT EXISTS businesses (
            id INTEGER PRIMARY KEY AUTOINCREMENT,
            business_id TEXT UNIQUE,
            name TEXT,
            type TEXT,
            owner_id INTEGER,
            income INTEGER,
            last_income_date TEXT,
            FOREIGN KEY (owner_id) REFERENCES citizens (id)
        )
    ''')

    # Добавление отеля по умолчанию
    c.execute("SELECT * FROM businesses WHERE business_id = ?", ("hotel_001",))
    if not c.fetchone():
        c.execute('''
            INSERT INTO businesses (business_id, name, type, owner_id, income, last_income_date)
            VALUES (?, ?, ?, ?, ?, ?)
        ''', (
            "hotel_001",
            "Либерти-Ситиьский отель",
            "отель",
            None,
            0,
            datetime.now(timezone.utc).strftime("%Y-%m-%d %H:%M:%S")
        ))

    c.execute('''
        CREATE TABLE IF NOT EXISTS business_employees (
            id INTEGER PRIMARY KEY AUTOINCREMENT,
            business_id TEXT,
            employee_id INTEGER,
            position TEXT,
            salary INTEGER,
            hire_date TEXT,
            FOREIGN KEY (business_id) REFERENCES businesses (business_id),
            FOREIGN KEY (employee_id) REFERENCES citizens (id)
        )
    ''')

    c.execute('''
        CREATE TABLE IF NOT EXISTS houses (
            id INTEGER PRIMARY KEY AUTOINCREMENT,
            house_id TEXT UNIQUE,
            district TEXT,
            address TEXT,
            price INTEGER,
            rent INTEGER,
            owner_id INTEGER DEFAULT NULL,
            renter_id INTEGER DEFAULT NULL,
            status TEXT DEFAULT 'available',
            FOREIGN KEY (owner_id) REFERENCES citizens (id),
            FOREIGN KEY (renter_id) REFERENCES citizens (id)
        )
    ''')

    c.execute('''
        CREATE TABLE IF NOT EXISTS stolen_vehicles (
            id INTEGER PRIMARY KEY AUTOINCREMENT,
            vehicle_id INTEGER,
            report_date TEXT,
            officer_id INTEGER,
            status TEXT DEFAULT 'stolen',
            reason TEXT,
            model TEXT,
            color TEXT,
            FOREIGN KEY (vehicle_id) REFERENCES vehicles (id)
        )
    ''')

    c.execute('''
        CREATE TABLE IF NOT EXISTS nicknames (
            id INTEGER PRIMARY KEY AUTOINCREMENT,
            user_id TEXT,
            nickname TEXT,
            timestamp TEXT
        )
    ''')

    c.execute('''
        CREATE TABLE IF NOT EXISTS fines (
            id INTEGER PRIMARY KEY AUTOINCREMENT,
            citizen_id INTEGER,
            amount INTEGER,
            reason TEXT,
            officer_id INTEGER,
            issue_date TEXT,
            due_date TEXT,
            paid BOOLEAN DEFAULT 0,
            FOREIGN KEY (citizen_id) REFERENCES citizens (id)
        )
    ''')

    c.execute('''
        CREATE TABLE IF NOT EXISTS biographies (
            id INTEGER PRIMARY KEY AUTOINCREMENT,
            citizen_id INTEGER,
            biography TEXT,
            blocked_from_gov BOOLEAN DEFAULT 0,
            FOREIGN KEY (citizen_id) REFERENCES citizens (id)
        )
    ''')

    c.execute('''
        CREATE TABLE IF NOT EXISTS criminal_records (
            id INTEGER PRIMARY KEY AUTOINCREMENT,
            citizen_id INTEGER,
            article TEXT,
            sentence_length INTEGER,
            parole BOOLEAN,
            arrest_date TEXT,
            release_date TEXT,
            released_by TEXT,
            release_reason TEXT,
            FOREIGN KEY (citizen_id) REFERENCES citizens (id)
        )
    ''')

    c.execute('''
        CREATE TABLE IF NOT EXISTS passport_applications (
            id INTEGER PRIMARY KEY AUTOINCREMENT,
            citizen_id INTEGER,
            application_date TEXT,
            status TEXT DEFAULT 'pending',
            biography TEXT,
            FOREIGN KEY (citizen_id) REFERENCES citizens (id)
        )
    ''')

    c.execute('''
        CREATE TABLE IF NOT EXISTS gov_restrictions (
            id INTEGER PRIMARY KEY AUTOINCREMENT,
            citizen_id INTEGER,
            reason TEXT,
            restriction_date TEXT,
            duration_days INTEGER,
            active BOOLEAN DEFAULT 1,
            FOREIGN KEY (citizen_id) REFERENCES citizens (id)
        )
    ''')

    c.execute('''
        CREATE TABLE IF NOT EXISTS medical_records (
            id INTEGER PRIMARY KEY AUTOINCREMENT,
            citizen_id INTEGER,
            record_date TEXT,
            doctor TEXT,
            diagnosis TEXT,
            notes TEXT,
            FOREIGN KEY (citizen_id) REFERENCES citizens (id)
        )
    ''')

    c.execute('''
        CREATE TABLE IF NOT EXISTS governor (
            id INTEGER PRIMARY KEY CHECK(id=1),
            state_of_emergency BOOLEAN DEFAULT 0,
            last_decree_date TEXT,
            salary_modifier REAL DEFAULT 1.0
        )
    ''')

    c.execute('''
        CREATE TABLE IF NOT EXISTS warns (
            user_id INTEGER PRIMARY KEY,
            warns INTEGER DEFAULT 0
        )
    ''')

    # Проверка заселения домов
    c.execute("SELECT COUNT(*) FROM houses")
    if c.fetchone()[0] == 0:
#from populate import populate_houses  # если у тебя есть функция populate_houses()
        populate_houses()

    conn.commit()
    conn.close()


def add_age_column_if_not_exists():
    conn = sqlite3.connect('liberty_country.db')
    c = conn.cursor()
    c.execute("PRAGMA table_info(citizens)")
    columns = [col[1] for col in c.fetchall()]
    if 'age' not in columns:
        c.execute("ALTER TABLE citizens ADD COLUMN age INTEGER DEFAULT 0")
        print("Добавлена колонка 'age' в citizens")
    else:
        print("Колонка 'age' уже существует")
    conn.commit()
    conn.close()

class AdminPanelView(discord.ui.View):
    def __init__(self):
        super().__init__(timeout=None)

    @discord.ui.button(label="👤 Досье игрока", style=discord.ButtonStyle.primary)
    async def dossier_button(self, interaction: discord.Interaction, button: discord.ui.Button):
        await interaction.response.send_modal(DossierModal())

    @discord.ui.button(label="⛔ Забанить игрока", style=discord.ButtonStyle.danger)
    async def ban_button(self, interaction: discord.Interaction, button: discord.ui.Button):
        await interaction.response.send_modal(BanModal())

    @discord.ui.button(label="✅ Разбанить игрока", style=discord.ButtonStyle.success)
    async def unban_button(self, interaction: discord.Interaction, button: discord.ui.Button):
        await interaction.response.send_modal(UnbanModal())

    @discord.ui.button(label="👑 Назначить админа", style=discord.ButtonStyle.primary)
    async def admin_button(self, interaction: discord.Interaction, button: discord.ui.Button):
        await interaction.response.send_modal(AdminModal())

    @discord.ui.button(label="💸 Управление деньгами", style=discord.ButtonStyle.secondary)
    async def money_button(self, interaction: discord.Interaction, button: discord.ui.Button):
        await interaction.response.send_modal(MoneyModal())

    @discord.ui.button(label="📘 Выдать паспорт", style=discord.ButtonStyle.success)
    async def give_passport_button(self, interaction: discord.Interaction, button: discord.ui.Button):
        await interaction.response.send_modal(AdminGivePassportModal())

    @discord.ui.button(label="📄 Изъять паспорт", style=discord.ButtonStyle.danger)
    async def revoke_passport(self, interaction: discord.Interaction, button: discord.ui.Button):
        await interaction.response.send_modal(AdminRevokePassportModal())

    @discord.ui.button(label="🏠 Выдать дом", style=discord.ButtonStyle.success)
    async def give_house(self, interaction: discord.Interaction, button: discord.ui.Button):
        await interaction.response.send_modal(AdminGiveHouseModal())

    @discord.ui.button(label="🏚️ Изъять дом", style=discord.ButtonStyle.danger)
    async def revoke_house(self, interaction: discord.Interaction, button: discord.ui.Button):
        await interaction.response.send_modal(AdminRevokeHouseModal())

    @discord.ui.button(label="🏢 Выдать бизнес", style=discord.ButtonStyle.success)
    async def give_business(self, interaction: discord.Interaction, button: discord.ui.Button):
        await interaction.response.send_modal(AdminGiveBusinessModal())

    @discord.ui.button(label="📉 Изъять бизнес", style=discord.ButtonStyle.danger)
    async def revoke_business(self, interaction: discord.Interaction, button: discord.ui.Button):
        await interaction.response.send_modal(AdminRevokeBusinessModal())

    @discord.ui.button(label="🎫 Выдать лицензию", style=discord.ButtonStyle.success)
    async def give_license(self, interaction: discord.Interaction, button: discord.ui.Button):
        await interaction.response.send_modal(AdminGiveLicenseModal())

    @discord.ui.button(label="❌ Изъять лицензию", style=discord.ButtonStyle.danger)
    async def revoke_license(self, interaction: discord.Interaction, button: discord.ui.Button):
        await interaction.response.send_modal(AdminRevokeLicenseModal())


class DossierModal(ui.Modal):
    def __init__(self):
        super().__init__(title="Просмотр досье")

        # Поле ввода Discord ID игрока
        self.user_id = ui.TextInput(
            label="Discord ID игрока",
            placeholder="123456789012345678",
            style=1
        )
        self.add_item(self.user_id)

    async def on_submit(self, interaction: discord.Interaction):
        try:
            discord_id = int(self.user_id.value)
        except ValueError:
            await interaction.response.send_message("❌ Неверный формат ID!", ephemeral=True)
            return

        citizen = get_citizen(discord_id)
        if not citizen:
            await interaction.response.send_message("❌ Игрок не найден в базе!", ephemeral=True)
            return

        target = await bot.fetch_user(discord_id)

        embed = discord.Embed(
            title="📘 Досье гражданина",
            color=discord.Color.teal()
        )
        embed.set_author(
            name=str(target),
            icon_url=target.display_avatar.url if target.avatar else None
        )
        embed.add_field(name="Имя", value=f"{citizen['first_name']} {citizen['last_name']}", inline=True)
        embed.add_field(name="Дата рождения", value=citizen['birth_date'], inline=True)
        embed.add_field(name="Место рождения", value=citizen['birth_place'], inline=True)
        embed.add_field(name="Проживание", value=citizen['residence'], inline=True)
        embed.add_field(name="Наличные", value=f"${citizen['cash']}", inline=True)
        embed.add_field(name="Банк", value=f"${citizen['bank']}", inline=True)
        embed.add_field(name="Работа", value=citizen.get("job", "Безработный"), inline=True)
        embed.add_field(name="Паспорт", value="✅ Есть" if citizen['passport_issued'] else "❌ Нет", inline=True)
        embed.add_field(name="Мед. книжка", value="✅ Есть" if citizen['medical_book'] else "❌ Нет", inline=True)
        embed.add_field(name="Лицензии", value=citizen['licenses'] or "Отсутствуют", inline=False)
        embed.set_footer(text=f"ID в базе: {citizen['id']} | Discord ID: {discord_id}")

        await interaction.response.send_message(embed=embed, ephemeral=True)


class AdminGivePassportModal(ui.Modal):
    def __init__(self):
        super().__init__(title="📘 Выдача паспорта")

        # Поля формы
        self.discord_id = ui.TextInput(
            label="Discord ID игрока",
            placeholder="123456789012345678",
            style=1
        )
        # Объединяем имя и фамилию в одно поле, т.к. в модалке нельзя более 5 полей
        self.full_name = ui.TextInput(
            label="Имя и фамилия",
            placeholder="Иван Иванов",
            style=1
        )
        self.birth_date = ui.TextInput(
            label="Дата рождения",
            placeholder="01.01.2000",
            style=1
        )
        self.birth_place = ui.TextInput(
            label="Место рождения",
            placeholder="Либерти-Сити",
            style=1
        )
        self.bio = ui.TextInput(
            label="Биография",
            style=2,
            placeholder="Опишите кратко..."
        )

        # Добавляем поля в модалку
        self.add_item(self.discord_id)
        self.add_item(self.full_name)
        self.add_item(self.birth_date)
        self.add_item(self.birth_place)
        self.add_item(self.bio)

    async def on_submit(self, interaction: discord.Interaction):
        try:
            discord_id = int(self.discord_id.value)
        except ValueError:
            await interaction.response.send_message("❌ Неверный формат Discord ID!", ephemeral=True)
            return

        # Разбираем полное имя на имя и фамилию (если указано обе)
        full = self.full_name.value.strip()
        parts = full.split(None, 1)
        if len(parts) == 0:
            first, last = '', ''
        elif len(parts) == 1:
            first, last = parts[0], ''
        else:
            first, last = parts[0], parts[1]

        conn = sqlite3.connect('liberty_country.db')
        c = conn.cursor()

        c.execute("SELECT * FROM citizens WHERE discord_id=?", (discord_id,))
        citizen = c.fetchone()

        if not citizen:
            # Новый гражданин
            c.execute("""
                INSERT INTO citizens 
                (discord_id, first_name, last_name, birth_date, birth_place, bio, passport_issued, blocked_government)
                VALUES (?, ?, ?, ?, ?, ?, 1, 0)
            """, (
                discord_id,
                first,
                last,
                self.birth_date.value,
                self.birth_place.value,
                self.bio.value
            ))
        else:
            # Обновление существующего
            c.execute("""
                UPDATE citizens SET 
                first_name=?, last_name=?, birth_date=?, birth_place=?, bio=?, passport_issued=1 
                WHERE discord_id=?
            """, (
                first,
                last,
                self.birth_date.value,
                self.birth_place.value,
                self.bio.value,
                discord_id
            ))

        conn.commit()
        conn.close()

        await interaction.response.send_message("✅ Паспорт успешно выдан!", ephemeral=True)

        

class AdminRevokePassportModal(discord.ui.Modal):
    def __init__(self):
        super().__init__(title="Изъять паспорт")
        self.user_id = ui.TextInput(label="Discord ID игрока", placeholder="123456789012345678")

    async def on_submit(self, interaction: discord.Interaction):
        discord_id = int(self.user_id.value)
        citizen = get_citizen(discord_id)
        if not citizen or not citizen['passport_issued']:
            await interaction.response.send_message("❌ Паспорт не найден!", ephemeral=True)
            return

        update_field(discord_id, "passport_issued", 0)
        await interaction.response.send_message("✅ Паспорт изъят!", ephemeral=True)
        
class AdminGiveHouseModal(discord.ui.Modal):
    def __init__(self):
        super().__init__(title="Выдать дом")
        self.user_id = discord.ui.TextInput(label="Discord ID игрока")
        self.address = discord.ui.TextInput(label="Адрес дома")
        self.add_item(self.user_id)
        self.add_item(self.address)

    async def on_submit(self, interaction: discord.Interaction):
        discord_id = int(self.user_id.value)
        add_house(discord_id, self.address.value)
        await interaction.response.send_message(f"✅ Дом по адресу {self.address.value} выдан!", ephemeral=True)


class AdminGiveBusinessModal(discord.ui.Modal):
    def __init__(self):
        super().__init__(title="Выдать бизнес")
        self.user_id = discord.ui.TextInput(
            label="Discord ID игрока",
            placeholder="123456789012345678",
            required=True
        )
        self.name = discord.ui.TextInput(
            label="Название бизнеса",
            placeholder="Мой Бизнес",
            required=True
        )
        self.income = discord.ui.TextInput(
            label="Доход в день",
            placeholder="Например: 100",
            required=True
        )
        self.add_item(self.user_id)
        self.add_item(self.name)
        self.add_item(self.income)

    async def on_submit(self, interaction: discord.Interaction):
        try:
            discord_id = int(self.user_id.value)
            business_name = self.name.value
            income = int(self.income.value)
            add_business(discord_id, business_name, income)
            await interaction.response.send_message(
                f"✅ Бизнес {business_name} выдан!", ephemeral=True
            )
        except ValueError:
            await interaction.response.send_message(
                "❌ Ошибка: проверьте введенные значения (ID и доход должны быть числами)",
                ephemeral=True
            )
        except Exception as e:
            await interaction.response.send_message(
                f"❌ Ошибка при выдаче бизнеса: {str(e)}",
                ephemeral=True
            )

class AdminRevokeBusinessModal(discord.ui.Modal):
    def __init__(self):
        super().__init__(title="Изъять бизнес")
    user_id = discord.ui.TextInput(label="Discord ID игрока")

    async def on_submit(self, interaction: discord.Interaction):
        discord_id = int(self.user_id.value)
        remove_business(discord_id)
        await interaction.response.send_message("✅ Бизнес изъят!", ephemeral=True)

class AdminGiveLicenseModal(discord.ui.Modal):
    def __init__(self):
        super().__init__(title="Выдать лицензию")
        self.license_name = discord.ui.TextInput(label="Название лицензии")
        self.add_item(self.license_name)

    async def on_submit(self, interaction: discord.Interaction):
        discord_id = int(self.user_id.value)
        add_license(discord_id, self.license_name.value)
        await interaction.response.send_message("✅ Лицензия выдана!", ephemeral=True)

class AdminRevokeLicenseModal(discord.ui.Modal):
    def __init__(self):
        super().__init__(title="Изъять лицензию")
        self.user_id = discord.ui.TextInput(
            label="Discord ID игрока",
            placeholder="123456789012345678",
            required=True
        )
        self.license_name = discord.ui.TextInput(
            label="Название лицензии",
            placeholder="Например: лицензия на оружие",
            required=True
        )
        self.add_item(self.user_id)
        self.add_item(self.license_name)

    async def on_submit(self, interaction: discord.Interaction):
        try:
            discord_id = int(self.user_id.value)
            remove_license(discord_id, self.license_name.value)
            await interaction.response.send_message("✅ Лицензия изъята!", ephemeral=True)
        except ValueError:
            await interaction.response.send_message("❌ ID пользователя — только число!", ephemeral=True)
        except Exception as e:
            await interaction.response.send_message(f"❌ Ошибка: {str(e)}", ephemeral=True)

class BanModal(discord.ui.Modal):
    def __init__(self):
        super().__init__(title="Блокировка игрока")
        self.user_id = discord.ui.TextInput(
            label="Discord ID игрока",
            placeholder="123456789012345678",
            required=True
        )
        self.reason = discord.ui.TextInput(
            label="Причина блокировки",
            style=2,
            placeholder="Укажите причину блокировки (обязательно)",
            required=True
        )
        self.add_item(self.user_id)
        self.add_item(self.reason)

    async def on_submit(self, interaction: discord.Interaction):
        try:
            user_id = int(self.user_id.value)
            target = await bot.fetch_user(user_id)

            # Проверяем, не забанен ли уже
            conn = sqlite3.connect('liberty_country.db')
            c = conn.cursor()
            c.execute("SELECT * FROM bans WHERE discord_id=?", (str(user_id),))
            if c.fetchone():
                await interaction.response.send_message("❌ Игрок уже заблокирован!", ephemeral=True)
                conn.close()
                return

            # Добавляем в базу
            ban_date = datetime.now(timezone.utc).strftime("%d.%m.%Y %H:%M")
            c.execute(
                "INSERT INTO bans (discord_id, reason, banned_by, ban_date) VALUES (?, ?, ?, ?)",
                (str(user_id), self.reason.value, str(interaction.user.id), ban_date)
            )
            conn.commit()
            conn.close()

            # Отправляем уведомление
            try:
                await target.send(f"🔒 Вы были заблокированы администратором. Причина: {self.reason.value}")
            except Exception:
                pass  # Не удалось отправить ЛС

            await interaction.response.send_message(
                f"✅ Игрок {target.display_name} заблокирован!", ephemeral=True)

        except ValueError:
            await interaction.response.send_message("❌ Неверный формат ID!", ephemeral=True)
        except Exception as e:
            await interaction.response.send_message(f"⚠️ Ошибка блокировки: {e}", ephemeral=True)



class UnbanModal(discord.ui.Modal):
    def __init__(self):
        super().__init__(title="Разблокировка игрока")
    user_id = discord.ui.TextInput(label="Discord ID игрока", placeholder="123456789012345678")

    async def on_submit(self, interaction: discord.Interaction):
        try:
            user_id = int(self.user_id.value)

            conn = sqlite3.connect('liberty_country.db')
            c = conn.cursor()
            c.execute("DELETE FROM bans WHERE discord_id=?", (str(user_id),))
            if c.rowcount == 0:
                await interaction.response.send_message("❌ Игрок не найден в списке заблокированных!", ephemeral=True)
            else:
                conn.commit()
                await interaction.response.send_message("✅ Игрок успешно разблокирован!", ephemeral=True)

                try:
                    target = await bot.fetch_user(user_id)
                    await target.send("🔓 Ваша блокировка была снята администратором.")
                except Exception as e:
                    print(f"Не удалось отправить сообщение пользователю: {e}")

            conn.close()

        except ValueError:
            await interaction.response.send_message("❌ Неверный формат ID!", ephemeral=True)
        except Exception as e:
            print(f"Ошибка при разблокировке: {e}")
            await interaction.response.send_message("⚠️ Произошла ошибка при разблокировке!", ephemeral=True)


class AdminModal(discord.ui.Modal):
    def __init__(self):
        super().__init__(title="Управление администраторами")
        self.user_id = discord.ui.TextInput(
            label="Discord ID игрока",
            placeholder="123456789012345678",
            required=True
        )
        self.action = discord.ui.TextInput(
            label="Действие (назначить/снять)",
            placeholder="назначить",
            required=True
        )
        self.add_item(self.user_id)
        self.add_item(self.action)

    async def on_submit(self, interaction: discord.Interaction):
        try:
            user_id = int(self.user_id.value)
        except ValueError:
            await interaction.response.send_message("❌ Неверный формат ID!", ephemeral=True)
            return

        target = interaction.guild.get_member(user_id)

        if not target:
            await interaction.response.send_message("❌ Пользователь не найден на сервере!", ephemeral=True)
            return

        admin_role = discord.utils.get(interaction.guild.roles, name="Admin")
        if not admin_role:
            admin_role = await interaction.guild.create_role(
                name="Admin",
                permissions=discord.Permissions.all()
            )

        action_str = self.action.value.lower().strip()
        if action_str == "назначить":
            await target.add_roles(admin_role)
            await interaction.response.send_message(
                f"✅ Пользователь {target.display_name} назначен администратором!",
                ephemeral=True
            )
        elif action_str == "снять":
            await target.remove_roles(admin_role)
            await interaction.response.send_message(
                f"✅ С пользователя {target.display_name} сняты права администратора!",
                ephemeral=True
            )
        else:
            await interaction.response.send_message(
                "❌ Неверное действие! Используйте 'назначить' или 'снять'",
                ephemeral=True
            )


class WarnLogView(View):
    def __init__(self, user_id, reason):
        super().__init__(timeout=None)
        self.user_id = user_id
        self.reason = reason

    @discord.ui.button(label="Оспорить", style=ButtonStyle.secondary, custom_id="appeal_warn")
    async def appeal(self, interaction: Interaction, button: Button):
        await interaction.response.send_message("Заявка на оспаривание отправлена.", ephemeral=True)

    @discord.ui.button(label="Удалить варн", style=ButtonStyle.success, custom_id="remove_warn")
    async def remove_warn(self, interaction: Interaction, button: Button):
        conn = sqlite3.connect('liberty_country.db')
        c = conn.cursor()
        c.execute("DELETE FROM warns WHERE user_id = ? AND reason = ?", (self.user_id, self.reason))
        conn.commit()
        conn.close()
        await interaction.response.send_message("Варн удалён.", ephemeral=True)

    @discord.ui.button(label="Забанить", style=ButtonStyle.danger, custom_id="ban_user")
    async def ban_user(self, interaction: Interaction, button: Button):
        guild = interaction.guild
        member = guild.get_member(self.user_id)
        if member:
            await member.ban(reason="Нарушение правил (по варнам)")
            await interaction.response.send_message("Пользователь забанен.", ephemeral=True)
        else:
            await interaction.response.send_message("Пользователь не найден.", ephemeral=True)


class MoneyModal(discord.ui.Modal):
    def __init__(self):
        super().__init__(title="Управление деньгами")
        self.user_id = discord.ui.TextInput(
            label="Discord ID игрока",
            placeholder="123456789012345678",
            required=True
        )
        self.amount = discord.ui.TextInput(
            label="Сумма",
            placeholder="1000",
            required=True
        )
        self.action = discord.ui.TextInput(
            label="Действие (добавить/снять)",
            placeholder="добавить",
            required=True
        )
        self.currency = discord.ui.TextInput(
            label="Валюта (наличные/банк)",
            placeholder="наличные",
            required=True
        )
        self.add_item(self.user_id)
        self.add_item(self.amount)
        self.add_item(self.action)
        self.add_item(self.currency)

    async def on_submit(self, interaction: discord.Interaction):
        try:
            user_id = int(self.user_id.value)
            amount = int(self.amount.value)
            action_str = self.action.value.lower().strip()
            currency_str = self.currency.value.lower().strip()

            citizen = get_citizen(user_id)
            if not citizen:
                await interaction.response.send_message("❌ Игрок не найден в базе!", ephemeral=True)
                return

            if currency_str not in ["наличные", "банк"]:
                await interaction.response.send_message(
                    "❌ Неверная валюта! Используйте 'наличные' или 'банк'",
                    ephemeral=True
                )
                return

            if action_str == "добавить":
                if currency_str == "наличные":
                    add_cash(user_id, amount)
                elif currency_str == "банк":
                    add_bank(user_id, amount)
                await interaction.response.send_message(
                    f"✅ Добавлено {amount}$ {currency_str} игроку ID {user_id}",
                    ephemeral=True
                )

            elif action_str == "снять":
                if currency_str == "наличные":
                    if citizen['cash'] < amount:
                        await interaction.response.send_message("❌ Недостаточно наличных у игрока!", ephemeral=True)
                        return
                    add_cash(user_id, -amount)
                elif currency_str == "банк":
                    if citizen['bank'] < amount:
                        await interaction.response.send_message("❌ Недостаточно средств в банке у игрока!", ephemeral=True)
                        return
                    add_bank(user_id, -amount)
                await interaction.response.send_message(
                    f"✅ Снято {amount}$ из {currency_str} у игрока ID {user_id}",
                    ephemeral=True
                )
            else:
                await interaction.response.send_message(
                    "❌ Неверное действие! Используйте 'добавить' или 'снять'",
                    ephemeral=True
                )
        except ValueError:
            await interaction.response.send_message("❌ ID и сумма должны быть числами!", ephemeral=True)
        except Exception as e:
            await interaction.response.send_message(
                f"❌ Ошибка: {str(e)}",
                ephemeral=True
            )




import discord


AUDIT_CHANNEL_ID = 1414250273630716055  # <-- твой канал

async def log_audit(bot, message: str):
    channel = bot.get_channel(AUDIT_CHANNEL_ID)
    if channel:
        now = datetime.now(timezone.utc).strftime("%Y-%m-%d %H:%M:%S UTC")
        embed = discord.Embed(
            title="🕵️ Аудит действия",
            description=message,
            color=0x2f3136
        )
        embed.set_footer(text=f"{now}")
        await channel.send(embed=embed)
    else:
        print(f"[AUDIT] {message} — ❌ Канал аудита не найден")
# —— ВСТАВИТЬ ЗДЕСЬ среди ваших команд ——

@bot.hybrid_command(name='губернатор')
@commands.check(lambda ctx: ctx.author.id in owner_id)
async def governor_panel(ctx):
    soe, mod = get_governor_settings()
    embed = discord.Embed(title="👑 Панель Губернатора", color=discord.Color.purple())
    embed.add_field(name="Чрезвычайное положение", value="Включено" if soe else "Отключено")
    embed.add_field(name="Множитель зарплат", value=f"{mod:.2f}×")
    await ctx.send(embed=embed, view=GovernorView())


class GovernorView(ui.View):
    @ui.button(label="🛑 Toggle ЧП", style=ButtonStyle.red)
    async def toggle_soe(self, interaction: discord.Interaction, button: ui.Button):
        try:
            soe, _ = get_governor_settings()
            set_state_of_emergency(not soe)
            await interaction.response.send_message(
                f"ЧП {'включено' if not soe else 'отключено'}", ephemeral=True
            )
        except Exception as e:
            print(f"Ошибка при переключении ЧП: {e}")
            await interaction.response.send_message("⚠️ Ошибка при переключении ЧП.", ephemeral=True)

    @ui.button(label="📈 Увеличить зарплаты", style=ButtonStyle.green)
    async def inc_mod(self, interaction: discord.Interaction, button: ui.Button):
        try:
            _, mod = get_governor_settings()
            new = round(mod + 0.10, 2)
            set_salary_modifier(new)
            await interaction.response.send_message(f"✅ Множитель зарплат увеличен до {new:.2f}×", ephemeral=True)
        except Exception as e:
            print(f"Ошибка при увеличении множителя: {e}")
            await interaction.response.send_message("⚠️ Ошибка при увеличении множителя.", ephemeral=True)

    @ui.button(label="📉 Уменьшить зарплаты", style=ButtonStyle.grey)
    async def dec_mod(self, interaction: discord.Interaction, button: ui.Button):
        try:
            _, mod = get_governor_settings()
            new = max(0.5, round(mod - 0.10, 2))
            set_salary_modifier(new)
            await interaction.response.send_message(f"✅ Множитель зарплат уменьшен до {new:.2f}×", ephemeral=True)
        except Exception as e:
            print(f"Ошибка при уменьшении множителя: {e}")
            await interaction.response.send_message("⚠️ Ошибка при уменьшении множителя.", ephemeral=True)


def populate_houses():
    districts = {
        "Либерти-Сити": [11032, 11031, 11091, 11092, 11121, 11122, 11123],
        "Фридом-Хиллс": [9041, 9042, 9043, 9044, 9073, 9071, 9072, 9061, 9062, 9082],
        "Юнити-Таун": [12021, 12022, 12051, 12052, 12053, 12054, 12055, 12056],
        "Централ-Авеню": [5061, 5062, 5063, 5044, 5043, 5042, 5041, 5051, 5052],
        "Грин-Вэлли": [4052, 4053, 4054, 4055, 4056],
        "Новый Порт": [7011, 7012, 7013, 7021, 7022, 7023, 7043, 7044, 7041, 7042, 7051, 7052, 7053, 7054, 7055, 7056,
                        7061, 7062, 7063, 7064, 7001, 7002, 7091, 7092, 7093, 7094, 7095]
    }

    try:
        with sqlite3.connect('liberty_country.db') as conn:
            c = conn.cursor()
            # Очищаем таблицу перед заполнением
            c.execute("DELETE FROM houses")

            # Цены в зависимости от района
            price_ranges = {
                "Либерти-Сити": (500000, 1000000),
                "Юнити-Таун": (400000, 800000),
                "Фридом-Хиллс": (300000, 600000),
                "Новый Порт": (250000, 500000),
                "Централ-Авеню": (100000, 300000),
                "Грин-Вэлли": (80000, 200000)
            }

            rent_ranges = {
                "Либерти-Сити": (500, 1000),
                "Юнити-Таун": (400, 800),
                "Фридом-Хиллс": (300, 600),
                "Новый Порт": (250, 500),
                "Централ-Авеню": (100, 300),
                "Грин-Вэлли": (80, 200)
            }

            for district, houses in districts.items():
                for house_id in houses:
                    price = random.randint(*price_ranges.get(district, (100000, 500000)))
                    rent = random.randint(*rent_ranges.get(district, (100, 500)))

                    c.execute("""
                        INSERT INTO houses (house_id, district, address, price, rent)
                        VALUES (?, ?, ?, ?, ?)
                    """, (str(house_id), district, f"{district}, дом {house_id}", price, rent))
            conn.commit()
    except sqlite3.OperationalError as e:
        print(f"[ОШИБКА] Не удалось заполнить таблицу houses: {e}")
    except Exception as e:
        print(f"[ОШИБКА] Неизвестная ошибка при заполнении houses: {e}")


class HouseView(ui.View):
    def __init__(self, house_id):
        super().__init__(timeout=180)
        self.house_id = house_id

    @ui.button(label="🏠 Купить дом", style=discord.ButtonStyle.green)
    async def buy_house(self, interaction: discord.Interaction, button: ui.Button):
        conn = sqlite3.connect('liberty_country.db')
        conn.row_factory = sqlite3.Row
        c = conn.cursor()

        try:
            # Проверка наличия паспорта у пользователя
            c.execute("SELECT * FROM citizens WHERE discord_id=?", (str(interaction.user.id),))
            citizen = c.fetchone()

            if not citizen:
                await interaction.response.send_message("❌ У вас нет паспорта!", ephemeral=True)
                return

            # Проверка, не владеет ли пользователь уже домом
            c.execute("SELECT * FROM houses WHERE owner_id=?", (citizen['id'],))
            if c.fetchone():
                await interaction.response.send_message("❌ Вы уже владеете домом!", ephemeral=True)
                return

            # Получение информации о доме
            c.execute("SELECT * FROM houses WHERE house_id=?", (self.house_id,))
            house = c.fetchone()

            if not house:
                await interaction.response.send_message("❌ Дом не найден!", ephemeral=True)
                return

            # Проверка доступности дома
            if house['status'] != 'available':
                await interaction.response.send_message("❌ Этот дом уже куплен или арендован!", ephemeral=True)
                return

            # Проверка баланса
            if citizen['bank'] < house['price']:
                await interaction.response.send_message(
                    f"❌ Недостаточно средств на счете! Нужно: {house['price']}$, у вас: {citizen['bank']}$",
                    ephemeral=True
                )
                return

            # Покупка дома
            c.execute("UPDATE citizens SET bank = bank - ? WHERE id=?", (house['price'], citizen['id']))
            c.execute("UPDATE houses SET owner_id = ?, status = 'owned' WHERE house_id=?", (citizen['id'], self.house_id))
            c.execute("UPDATE citizens SET residence = ? WHERE id=?", (house['address'], citizen['id']))
            
            conn.commit()
            
            # Формирование ответа
            embed = discord.Embed(
                title="🏠 ПОЗДРАВЛЯЕМ С ПОКУПКОЙ ДОМА!",
                description=f"Вы стали владельцем дома по адресу: {house['address']}",
                color=discord.Color.green()
            )
            embed.add_field(name="Цена", value=f"${house['price']}", inline=True)
            embed.add_field(name="Новый адрес", value=house['address'], inline=True)
            embed.set_footer(text="Теперь это ваш постоянный адрес проживания")
            
            await interaction.response.send_message(embed=embed, ephemeral=True)
            
        except Exception as e:
            print(f"Ошибка при покупке дома: {e}")
            await interaction.response.send_message("❌ Произошла ошибка при обработке запроса", ephemeral=True)
        finally:
            conn.close()

    @ui.button(label="🔑 Арендовать", style=discord.ButtonStyle.primary)
    async def rent_house(self, interaction: discord.Interaction, button: ui.Button):
        conn = sqlite3.connect('liberty_country.db')
        conn.row_factory = sqlite3.Row
        c = conn.cursor()
        
        try:
            # Получение информации о доме
            c.execute("SELECT * FROM houses WHERE house_id=?", (self.house_id,))
            house = c.fetchone()

            if not house:
                await interaction.response.send_message("❌ Дом не найден!", ephemeral=True)
                return

            # Проверка наличия паспорта у пользователя
            c.execute("SELECT * FROM citizens WHERE discord_id=?", (str(interaction.user.id),))
            citizen = c.fetchone()

            if not citizen:
                await interaction.response.send_message("❌ У вас нет паспорта!", ephemeral=True)
                return

            # Проверка доступности дома
            if house['status'] != 'available':
                await interaction.response.send_message("❌ Этот дом уже куплен или арендован!", ephemeral=True)
                return

            # Проверка наличных
            if citizen['cash'] < house['rent']:
                await interaction.response.send_message(
                    f"❌ Недостаточно наличных! Нужно: {house['rent']}$, у вас: {citizen['cash']}$",
                    ephemeral=True
                )
                return

            # Оформление аренды
            c.execute("UPDATE citizens SET cash = cash - ? WHERE id=?", (house['rent'], citizen['id']))
            c.execute("UPDATE houses SET renter_id = ?, status = 'rented' WHERE house_id=?", (citizen['id'], self.house_id))
            c.execute("UPDATE citizens SET residence = ? WHERE id=?", (house['address'], citizen['id']))

            conn.commit()
            
            # Формирование ответа
            embed = discord.Embed(
                title="🔑 ВЫ АРЕНДОВАЛИ ДОМ!",
                description=f"Вы арендовали дом по адресу: {house['address']}",
                color=discord.Color.blue()
            )
            embed.add_field(name="Арендная плата", value=f"${house['rent']}/день", inline=True)
            embed.add_field(name="Новый адрес", value=house['address'], inline=True)
            embed.set_footer(text="Аренда действительна до следующего игрового дня")

            await interaction.response.send_message(embed=embed, ephemeral=True)
            
        except Exception as e:
            print(f"Ошибка при аренде дома: {e}")
            await interaction.response.send_message("❌ Произошла ошибка при обработке запроса", ephemeral=True)
        finally:
            conn.close()


@bot.hybrid_command(name='дома')
async def list_houses(ctx, district: str = None):
    conn = sqlite3.connect('liberty_country.db')
    conn.row_factory = sqlite3.Row
    c = conn.cursor()

    try:
        if district:
            c.execute("SELECT * FROM houses WHERE district=? AND status='available'", (district,))
        else:
            c.execute("SELECT * FROM houses WHERE status='available'")

        houses = c.fetchall()

        if not houses:
            await ctx.send("❌ Нет доступных домов в этом районе!")
            return

        embed = discord.Embed(
            title=f"🏠 ДОСТУПНЫЕ ДОМА {'В РАЙОНЕ ' + district.upper() if district else ''}",
            color=discord.Color.green()
        )

        # Ограничиваем количество домов до 25
        houses = houses[:25]

        for house in houses:
            embed.add_field(
                name=f"Дом #{house['house_id']}",
                value=f"Адрес: {house['address']}\n"
                      f"Цена покупки: ${house['price']}\n"
                      f"Аренда: ${house['rent']}/день",
                inline=False
            )

        embed.set_footer(text="Используйте !дом [номер дома] для просмотра деталей")
        await ctx.send(embed=embed)
        
    finally:
        conn.close()


@bot.hybrid_command(name="adminpanel")
@commands.has_permissions(administrator=True)
async def admin_panel(ctx):
    await ctx.send("⚙️ **Административная панель:**", view=AdminPanelView())

@bot.hybrid_command(name='дом')
async def house_details(ctx, house_id: str):
    conn = sqlite3.connect('liberty_country.db')
    conn.row_factory = sqlite3.Row
    c = conn.cursor()

    c.execute("SELECT * FROM houses WHERE house_id=?", (house_id,))
    house = c.fetchone()
    conn.close()

    if not house:
        await ctx.send("❌ Дом с таким ID не найден!")
        return

    status_map = {
        'available': '✅ Свободен',
        'owned': '🔒 Владелец',
        'rented': '🔑 Арендован'
    }

    embed = discord.Embed(
        title=f"🏠 ДОМ #{house['house_id']}",
        description=f"Адрес: {house['address']}",
        color=discord.Color.blue()
    )
    embed.add_field(name="Район", value=house['district'], inline=True)
    embed.add_field(name="Статус", value=status_map.get(house['status'], house['status']), inline=True)
    embed.add_field(name="Цена покупки", value=f"${house['price']}", inline=True)
    embed.add_field(name="Арендная плата", value=f"${house['rent']}/день", inline=True)

    if house['status'] == 'available':
        await ctx.send(embed=embed, view=HouseView(house['house_id']))
    else:
        await ctx.send(embed=embed)


@bot.hybrid_command(name='мой_дом')
async def my_house(ctx):
    citizen = get_citizen(ctx.author.id)
    if not citizen:
        await ctx.send("❌ У вас нет паспорта!")
        return

    conn = sqlite3.connect('liberty_country.db')
    conn.row_factory = sqlite3.Row
    c = conn.cursor()

    # Проверяем, владеет ли пользователь домом или арендует его
    c.execute("SELECT * FROM houses WHERE owner_id=? OR renter_id=?", (citizen['id'], citizen['id']))
    house = c.fetchone()
    conn.close()

    if not house:
        await ctx.send("❌ У вас нет дома! Посмотрите доступные дома: !дома")
        return

    status = "Владелец" if house['owner_id'] == citizen['id'] else "Арендатор"

    embed = discord.Embed(
        title=f"🏠 ВАШ ДОМ",
        description=f"Адрес: {house['address']}",
        color=discord.Color.gold()
    )
    embed.add_field(name="Статус", value=status, inline=True)
    embed.add_field(name="Район", value=house['district'], inline=True)

    if status == "Арендатор":
        embed.add_field(name="Арендная плата", value=f"${house['rent']}/день", inline=True)
        embed.set_footer(text="Аренда продлевается автоматически при наличии средств")

    await ctx.send(embed=embed)


# Проверка прав доступа
def is_owner(ctx):
    return ctx.author.id in owner_id


def is_police(ctx):
    if is_owner(ctx):
        return True
    police_roles = ['LCPD', 'LCSD', 'DOJ']
    if not ctx.guild or not isinstance(ctx.author, discord.Member):
        return False
    return any(role.name in police_roles for role in ctx.author.roles)


# Классы для модальных окон
class WarrantModal(discord.ui.Modal):
    def __init__(self):
        super().__init__(title="Объявление в розыск")
    nickname = discord.ui.TextInput(
        label="Никнейм игрока",
        placeholder="Введите никнейм игрока",
        style=1
    )
    level = discord.ui.TextInput(
        label="Уровень розыска (1-5)",
        placeholder="1-5",
        style=discord.ui.TextInput
    )
    reason = discord.ui.TextInput(
        label="Причина розыска",
        placeholder="Статьи УК...",
        style= 2
    )
    description = discord.ui.TextInput(
        label="Приметы/Описание",
        placeholder="Внешность, особые приметы...",
        style=2,
        required=False
    )

    async def on_submit(self, interaction: discord.Interaction):
        try:
            # Проверка уровня розыска
            level = int(self.level.value)
            if level < 1 or level > 5:
                await interaction.response.send_message(
                    "❌ Уровень розыска должен быть от 1 до 5!",
                    ephemeral=True
                )
                return
        except ValueError:
            await interaction.response.send_message(
                "❌ Неверный формат уровня розыска! Введите число от 1 до 5.",
                ephemeral=True
            )
            return

        conn = sqlite3.connect('liberty_country.db')
        conn.row_factory = sqlite3.Row
        c = conn.cursor()

        try:
            # Поиск гражданина по никнейму
            c.execute("""
                SELECT * FROM citizens 
                WHERE discord_id IN (
                    SELECT user_id FROM nicknames 
                    WHERE nickname LIKE ?
                )
            """, (f"%{self.nickname.value}%",))
            citizen = c.fetchone()

            if not citizen:
                await interaction.response.send_message(
                    "❌ Гражданин не найден!",
                    ephemeral=True
                )
                return

            # Создание ордера на розыск
            issue_date = datetime.now(timezone.utc).strftime("%d.%m.%Y %H:%M")
            c.execute("""
                INSERT INTO warrants (citizen_id, reason, officer_id, issue_date, level, description)
                VALUES (?, ?, ?, ?, ?, ?)
            """, (
                citizen['id'],
                self.reason.value,
                interaction.user.id,
                issue_date,
                level,
                self.description.value
            ))
            conn.commit()

            # Отправка уведомления в канал розыска
            warrant_channel = discord.utils.get(interaction.guild.channels, name="розыск")
            if warrant_channel:
                embed = discord.Embed(
                    title=f"📌 УГОЛОВНЫЙ РОЗЫСК ({'★' * level})",
                    color=discord.Color.red()
                )
                embed.add_field(
                    name="Гражданин",
                    value=f"{citizen['first_name']} {citizen['last_name']} (ID: {citizen['id']})",
                    inline=False
                )
                embed.add_field(name="Причина", value=self.reason.value, inline=False)
                embed.add_field(name="Приметы", value=self.description.value or "Не указаны", inline=False)
                embed.add_field(name="Офицер", value=interaction.user.mention, inline=True)
                embed.add_field(name="Дата", value=issue_date, inline=True)
                await warrant_channel.send(embed=embed)

            await interaction.response.send_message("✅ Розыск успешно объявлен!", ephemeral=True)
            
        except Exception as e:
            print(f"Ошибка при объявлении розыска: {e}")
            await interaction.response.send_message(
                "❌ Произошла ошибка при объявлении розыска.",
                ephemeral=True
            )
        finally:
            conn.close()


class ClearWarrantModal(discord.ui.Modal):
    def __init__(self):
        super().__init__(title="Снятие с розыска")
    nickname = discord.ui.TextInput(
        label="Никнейм игрока",
        placeholder="Введите никнейм игрока",
        style=1
    )
    reason = discord.ui.TextInput(
        label="Причина снятия",
        placeholder="Задержание, снятие обвинений...",
        style=2
    )

    async def on_submit(self, interaction: discord.Interaction):
        conn = sqlite3.connect('liberty_country.db')
        conn.row_factory = sqlite3.Row
        c = conn.cursor()

        c.execute("SELECT * FROM citizens WHERE discord_id IN (SELECT user_id FROM nicknames WHERE nickname LIKE ?)",
                  (f"%{self.nickname.value}%",))
        citizen = c.fetchone()

        if not citizen:
            await interaction.response.send_message(
                "❌ Гражданин не найден!",
                ephemeral=True
            )
            conn.close()
            return

        c.execute("SELECT * FROM warrants WHERE citizen_id=? AND status='active'", (citizen['id'],))
        warrant = c.fetchone()

        if not warrant:
            await interaction.response.send_message(
                "❌ Активный розыск не найден!",
                ephemeral=True
            )
            conn.close()
            return

        c.execute("UPDATE warrants SET status='cleared' WHERE id=?", (warrant['id'],))
        conn.commit()
        conn.close()

        clear_channel = discord.utils.get(interaction.guild.channels, name="снятие-розыска")
        if clear_channel:
            embed = discord.Embed(
                title="✅ РОЗЫСК СНЯТ",
                color=discord.Color.green()
            )
            embed.add_field(
                name="Гражданин",
                value=f"{citizen['first_name']} {citizen['last_name']} (ID: {citizen['id']})",
                inline=False
            )
            embed.add_field(name="Причина снятия", value=self.reason.value, inline=False)
            embed.add_field(name="Офицер", value=interaction.user.mention, inline=True)
            embed.add_field(
                name="Дата снятия",
                value=datetime.now(timezone.utc).strftime("%d.%m.%Y %H:%M"),
                inline=True
            )
            await clear_channel.send(embed=embed)

        await interaction.response.send_message("✅ Розыск успешно снят!", ephemeral=True)


class StolenCarModal(discord.ui.Modal):
    def __init__(self):
        super().__init__(title="Регистрация угона")
    plate = discord.ui.TextInput(
        label="Гос. номер",
        placeholder="XXX-000",
        style=1
    )
    model = discord.ui.TextInput(
        label="Модель авто",
        placeholder="Toyota Camry",
        style=1
    )
    color = discord.ui.TextInput(
        label="Цвет авто",
        placeholder="Красный",
        style=1
    )
    reason = discord.ui.TextInput(
        label="Причина/Обстоятельства",
        placeholder="Обстоятельства угона...",
        style=2
    )

    async def on_submit(self, interaction: discord.Interaction):
        conn = sqlite3.connect('liberty_country.db')
        conn.row_factory = sqlite3.Row
        c = conn.cursor()

        c.execute("SELECT * FROM vehicles WHERE plate=?", (self.plate.value.upper(),))
        vehicle = c.fetchone()

        if not vehicle:
            await interaction.response.send_message(
                "❌ Транспортное средство не найдено!",
                ephemeral=True
            )
            conn.close()
            return

        c.execute("SELECT * FROM stolen_vehicles WHERE vehicle_id=? AND status='stolen'", (vehicle['id'],))
        if c.fetchone():
            await interaction.response.send_message(
                "ℹ️ Транспорт уже помечен как угнанный!",
                ephemeral=True
            )
            conn.close()
            return

        report_date = datetime.now(timezone.utc).strftime("%d.%m.%Y %H:%M")
        c.execute("""
            INSERT INTO stolen_vehicles (vehicle_id, report_date, officer_id, reason, status, model, color)
            VALUES (?, ?, ?, ?, 'stolen', ?, ?)
        """, (vehicle['id'], report_date, interaction.user.id, self.reason.value, self.model.value, self.color.value))

        c.execute("SELECT * FROM citizens WHERE id=?", (vehicle['owner_id'],))
        owner = c.fetchone()

        conn.commit()
        conn.close()

        stolen_channel = discord.utils.get(interaction.guild.channels, name="угон-авто")
        if stolen_channel:
            embed = discord.Embed(
                title="🚨 ТРАНСПОРТ В УГОНЕ",
                color=discord.Color.red()
            )
            embed.add_field(name="Гос. номер", value=self.plate.value.upper(), inline=False)
            embed.add_field(name="Модель", value=self.model.value, inline=True)
            embed.add_field(name="Цвет", value=self.color.value, inline=True)
            embed.add_field(

                name="Владелец",
                value=f"{owner['first_name']} {owner['last_name']} (ID: {owner['id']})",
                inline=False
            )
            embed.add_field(name="Причина", value=self.reason.value, inline=False)
            embed.add_field(name="Офицер", value=interaction.user.mention, inline=True)
            embed.add_field(name="Дата", value=report_date, inline=True)
            await stolen_channel.send(embed=embed)

        await interaction.response.send_message("✅ Транспорт успешно помечен как угнанный!", ephemeral=True)


class VehicleModal(discord.ui.Modal):
    def __init__(self):
        super().__init__(title="Проверка транспортного средства")
    plate = discord.ui.TextInput(
        label="Гос. номер",
        placeholder="Введите гос. номер",
        style=1
    )

    async def on_submit(self, interaction: discord.Interaction):
        plate_upper = self.plate.value.upper()
        conn = sqlite3.connect('liberty_country.db')
        conn.row_factory = sqlite3.Row
        c = conn.cursor()
        c.execute("SELECT * FROM vehicles WHERE plate=?", (plate_upper,))
        vehicle = c.fetchone()
        conn.close()

        if not vehicle:
            await interaction.response.send_message("❌ Транспортное средство не найдено!", ephemeral=True)
            return

        owner_id = vehicle['owner_id']
        # Получаем владельца
        conn = sqlite3.connect('liberty_country.db')
        conn.row_factory = sqlite3.Row
        c = conn.cursor()
        c.execute("SELECT * FROM citizens WHERE id=?", (owner_id,))
        owner = c.fetchone()
        conn.close()

        embed = discord.Embed(
            title=f"Информация по ТС {plate_upper}",
            color=discord.Color.blue()
        )
        embed.add_field(name="Модель", value=vehicle['model'], inline=True)
        embed.add_field(name="Цвет", value=vehicle['color'], inline=True)
        if owner:
            embed.add_field(name="Владелец", value=f"{owner['first_name']} {owner['last_name']} (ID: {owner['id']})", inline=False)
        else:
            embed.add_field(name="Владелец", value="Не найден", inline=False)

        await interaction.response.send_message(embed=embed, ephemeral=True)


class RecoverCarModal(discord.ui.Modal):
    def __init__(self):
        super().__init__(title="Снятие с угона")
    plate = discord.ui.TextInput(
        label="Гос. номер",
        placeholder="XXX-000",
        style=1
    )
    reason = discord.ui.TextInput(
        label="Причина снятия",
        placeholder="Транспорт найден, ошибка...",
        style=2
    )

    async def on_submit(self, interaction: discord.Interaction):
        conn = sqlite3.connect('liberty_country.db')
        conn.row_factory = sqlite3.Row
        c = conn.cursor()

        c.execute("SELECT * FROM vehicles WHERE plate=?", (self.plate.value.upper(),))
        vehicle = c.fetchone()

        if not vehicle:
            await interaction.response.send_message(
                "❌ Транспортное средство не найдено!",
                ephemeral=True
            )
            conn.close()
            return

        c.execute("SELECT * FROM stolen_vehicles WHERE vehicle_id=? AND status='stolen'", (vehicle['id'],))
        stolen_record = c.fetchone()

        if not stolen_record:
            await interaction.response.send_message(
                "❌ Нет активных записей об угонах для этого транспорта!",
                ephemeral=True
            )
            conn.close()
            return

        recover_date = datetime.now(timezone.utc).strftime("%d.%m.%Y %H:%M")
        c.execute("""
            UPDATE stolen_vehicles
            SET status='recovered', reason=?
            WHERE id=?
        """, (self.reason.value, stolen_record['id']))

        conn.commit()
        conn.close()

        recovered_channel = discord.utils.get(interaction.guild.channels, name="возврат-авто")
        if recovered_channel:
            embed = discord.Embed(
                title="✅ ТРАНСПОРТ ВОЗВРАЩЕН",
                color=discord.Color.green()
            )
            embed.add_field(name="Гос. номер", value=self.plate.value.upper(), inline=False)
            embed.add_field(name="Модель", value=vehicle['model'], inline=True)
            embed.add_field(name="Причина снятия", value=self.reason.value, inline=False)
            embed.add_field(name="Офицер", value=interaction.user.mention, inline=True)
            embed.add_field(name="Дата возврата", value=recover_date, inline=True)
            await recovered_channel.send(embed=embed)

        await interaction.response.send_message("✅ Транспорт успешно снят с угона!", ephemeral=True)


class FineModal(discord.ui.Modal):
    def __init__(self):
        super().__init__(title="Выписать штраф")
    nickname = discord.ui.TextInput(
        label="Никнейм игрока",
        placeholder="Введите никнейм игрока",
        style=1
    )
    amount = discord.ui.TextInput(
        label="Сумма штрафа ($)",
        placeholder="100-10000",
        style=1
    )
    reason = discord.ui.TextInput(
        label="Причина штрафа",
        placeholder="Нарушение ПДД, хулиганство...",
        style=2
    )

    async def on_submit(self, interaction: discord.Interaction):
        try:
            amount_val = int(self.amount.value)
            if amount_val < 100 or amount_val > 10000:
                await interaction.response.send_message(
                    "❌ Сумма штрафа должна быть от 100 до 10,000$!",
                    ephemeral=True
                )
                return
        except ValueError:
            await interaction.response.send_message(
                "❌ Неверный формат суммы штрафа!",
                ephemeral=True
            )
            return

        conn = sqlite3.connect('liberty_country.db')
        conn.row_factory = sqlite3.Row
        c = conn.cursor()

        c.execute("SELECT * FROM citizens WHERE discord_id IN (SELECT user_id FROM nicknames WHERE nickname LIKE ?)",
                  (f"%{self.nickname.value}%",))
        citizen = c.fetchone()

        if not citizen:
            await interaction.response.send_message(
                "❌ Гражданин не найден!",
                ephemeral=True
            )
            conn.close()
            return

        issue_date = datetime.now(timezone.utc).strftime("%d.%m.%Y %H:%M")
        due_date = (datetime.now(timezone.utc) + datetime.timedelta(days=7)).strftime("%d.%m.%Y")

        c.execute("""
            INSERT INTO fines (citizen_id, amount, reason, officer_id, issue_date, due_date)
            VALUES (?, ?, ?, ?, ?, ?)
        """, (
            citizen['id'],
            amount_val,
            self.reason.value,
            interaction.user.id,
            issue_date,
            due_date
        ))

        conn.commit()
        conn.close()

        fine_channel = discord.utils.get(interaction.guild.channels, name="штрафы")
        if fine_channel:
            embed = discord.Embed(
                title="📝 ВЫПИСАН ШТРАФ",
                color=discord.Color.orange()
            )
            embed.add_field(
                name="Гражданин",
                value=f"{citizen['first_name']} {citizen['last_name']} (ID: {citizen['id']})",
                inline=False
            )
            embed.add_field(name="Сумма", value=f"💵 {amount_val}$", inline=True)
            embed.add_field(name="Причина", value=self.reason.value, inline=True)
            embed.add_field(name="Офицер", value=interaction.user.mention, inline=True)
            embed.add_field(name="Дата выдачи", value=issue_date, inline=True)
            embed.add_field(name="Срок оплаты", value=due_date, inline=True)
            await fine_channel.send(embed=embed)

        await interaction.response.send_message("✅ Штраф успешно выписан!", ephemeral=True)

class LawuSearchModal(discord.ui.Modal):
    def __init__(self):
        super().__init__(title="Поиск статьи УК")
    query = discord.ui.TextInput(
        label="Номер статьи или ключевые слова",
        placeholder="Пример: 6.2, убийство, наркотики...",
        style=2
    )

    async def on_submit(self, interaction: discord.Interaction):
        results = search_criminal_code(self.query.value)

        if not results:
            await interaction.response.send_message(
                "❌ Статьи по вашему запросу не найдены!",
                ephemeral=True
            )
            return

        # Если найдена ровно одна статья - показываем сразу
        if len(results) == 1:
            result = results[0]
            embed = self.create_law_embed(result)
            await interaction.response.send_message(embed=embed, ephemeral=True)
        else:
            # Если несколько статей - предлагаем выбор
            view = LawSelectionView(results)
            embed = discord.Embed(
                title="🔍 РЕЗУЛЬТАТЫ ПОИСКА",
                description=f"Найдено {len(results)} результатов по запросу: '{self.query.value}'",
                color=discord.Color.blue()
            )
            await interaction.response.send_message(embed=embed, view=view, ephemeral=True)

        def create_law_embed(self, result):

            if result['type'] == 'chapter':
                embed = discord.Embed(
                    title=f"📖 ГЛАВА {result['number']}. {result['title']}",
                    color=discord.Color.dark_gold()
                )

                # Добавляем разделы, если есть
                if 'sections' in result['content']:
                    for section_num, section_data in result['content']['sections'].items():
                        embed.add_field(

                            name=f"🔹 Раздел {section_num}. {section_data['title']}",
                            value="\n".join([
                                f"• Статья {art_num}: {art_data['title']}"
                                for art_num, art_data in section_data['articles'].items()
                            ]),
                            inline=False
                        )

                # Добавляем статьи без разделов
                if 'articles' in result['content']:
                    for article_num, article_data in result['content']['articles'].items():
                        embed.add_field(
                            name=f"🔹 Статья {article_num}: {article_data['title']}",
                            value=article_data['description'],
                            inline=False
                        )

                return embed

            elif result['type'] == 'section':
                embed = discord.Embed(
                    title=f"📚 РАЗДЕЛ {result['number']}. {result['title']}",
                    color=discord.Color.dark_gold()
                )

                # Добавляем статьи
                for article_num, article_data in result['content']['articles'].items():
                    penalty_text = f"\nНаказание: {article_data['penalty']}" if article_data['penalty'] else ""
                    priority_text = f"\nПриоритет: {'★' * article_data['priority']}" if article_data['priority'] else ""

                    embed.add_field(
                        name=f"🔹 Статья {article_num}: {article_data['title']}",
                        value=f"{article_data['description']}{penalty_text}{priority_text}",
                        inline=False
                    )

                return embed

            elif result['type'] == 'article':
                article_data = result['content']
                penalty_text = f"\nНаказание: {article_data['penalty']}" if article_data['penalty'] else ""
                priority_text = f"\nПриоритет: {'★' * article_data['priority']}" if article_data['priority'] else ""
                type_text = f"\nТип: {article_data['type']}" if article_data['type'] else ""

                embed = discord.Embed(
                    title=f"⚖️ СТАТЬЯ {result['number']}: {article_data['title']}",
                    description=f"{article_data['description']}{penalty_text}{priority_text}{type_text}",
                    color=discord.Color.dark_gold()
                )
                return embed




# Классы для View
from discord import ui, ButtonStyle, Interaction

class MDTView(ui.View):
    def __init__(self):
        super().__init__(timeout=None)

    @ui.button(label="Объявить в розыск", style=ButtonStyle.danger, custom_id="mdt_warrant")
    async def warrant_button(self, interaction: Interaction, button: ui.Button):
        await interaction.response.send_modal(WarrantModal())

    @ui.button(label="Снять с розыска", style=ButtonStyle.success, custom_id="mdt_clear")
    async def clear_button(self, interaction: Interaction, button: ui.Button):
        await interaction.response.send_modal(ClearWarrantModal())

    @ui.button(label="Угон авто", style=ButtonStyle.danger, custom_id="mdt_stolen")
    async def stolen_button(self, interaction: Interaction, button: ui.Button):
        await interaction.response.send_modal(StolenCarModal())

    @ui.button(label="Снять угон", style=ButtonStyle.success, custom_id="mdt_recover")
    async def recover_button(self, interaction: Interaction, button: ui.Button):
        await interaction.response.send_modal(RecoverCarModal())

    @ui.button(label="Поиск гражданина", style=ButtonStyle.primary, custom_id="mdt_search")
    async def search_button(self, interaction: Interaction, button: ui.Button):
        await interaction.response.send_modal(LawSearchModal())  # или замени на существующий модал

    @ui.button(label="Проверить ТС", style=ButtonStyle.primary, custom_id="mdt_vehicle")
    async def vehicle_button(self, interaction: Interaction, button: ui.Button):
        await interaction.response.send_modal(VehicleModal())  # добавь VehicleModal

    @ui.button(label="Выписать штраф", style=ButtonStyle.secondary, custom_id="mdt_fine")
    async def fine_button(self, interaction: Interaction, button: ui.Button):
        await interaction.response.send_modal(FineModal())

    @ui.button(label="Проверить штрафы", style=ButtonStyle.primary, custom_id="mdt_fines")
    async def fines_button(self, interaction: Interaction, button: ui.Button):
        await interaction.response.send_modal(FineModal())  # пока заменил на FineModal

    @ui.button(label="Поиск статьи УК", style=ButtonStyle.primary, custom_id="mdt_law_search")
    async def law_search_button(self, interaction: Interaction, button: ui.Button):
        await interaction.response.send_modal(LawSearchModal())

class AdminRevokeHouseModal(discord.ui.Modal):
    """Изъятие дома у гражданина"""
    def __init__(self):
        super().__init__(title="Изъять дом")
        self.user_id = discord.ui.TextInput(label="Discord ID игрока", required=True)
        self.add_item(self.user_id)

    async def on_submit(self, interaction: discord.Interaction):
        try:
            discord_id = int(self.user_id.value)
            conn = sqlite3.connect('liberty_country.db')
            conn.row_factory = sqlite3.Row
            c = conn.cursor()
            c.execute("SELECT id FROM citizens WHERE discord_id=?", (str(discord_id),))
            citizen = c.fetchone()

            if not citizen:
                await interaction.response.send_message("❌ Гражданин не найден!", ephemeral=True)
                conn.close()
                return

            c.execute("DELETE FROM houses WHERE owner_id=?", (citizen['id'],))
            c.execute("UPDATE citizens SET residence=NULL WHERE id=?", (citizen['id'],))
            conn.commit()
            conn.close()
            await interaction.response.send_message("✅ Дом изъят!", ephemeral=True)
        except ValueError:
            await interaction.response.send_message("❌ Discord ID должен быть числом!", ephemeral=True)
        except Exception as e:
            await interaction.response.send_message(f"❌ Ошибка: {str(e)}", ephemeral=True)


class LawSearchModal(discord.ui.Modal):
    """Поиск законов"""
    def __init__(self):
        super().__init__(title="Поиск закона")
        self.query = discord.ui.TextInput(label="Введите статью", required=True, max_length=100)
        self.add_item(self.query)

    async def on_submit(self, interaction: discord.Interaction):
        try:
            query = self.query.value.lower()
            conn = sqlite3.connect('liberty_country.db')
            conn.row_factory = sqlite3.Row
            c = conn.cursor()

            c.execute("""
                SELECT * FROM criminal_code 
                WHERE LOWER(article) LIKE ? OR LOWER(description) LIKE ?
                LIMIT 5
            """, (f'%{query}%', f'%{query}%'))

            results = c.fetchall()
            conn.close()

            if not results:
                await interaction.response.send_message(f"❌ Законы не найдены", ephemeral=True)
                return

            embed = discord.Embed(
                title="📜 Результаты поиска",
                color=discord.Color.blue(),
                description=f"Найдено {len(results)} результатов"
            )

            for law in results:
                embed.add_field(
                    name=f"Статья {law['article']}",
                    value=law['description'][:100] if len(law['description']) > 100 else law['description'],
                    inline=False
                )

            await interaction.response.send_message(embed=embed, ephemeral=True)
        except Exception as e:
            await interaction.response.send_message(f"❌ Ошибка: {str(e)}", ephemeral=True)


class LawSearchModal2(discord.ui.Modal):
    """Альтернативный поиск закона (для других команд)"""
    def __init__(self):
        super().__init__(title="Найти закон")
        self.law_id = discord.ui.TextInput(label="Номер закона", required=True)
        self.add_item(self.law_id)

    async def on_submit(self, interaction: discord.Interaction):
        try:
            law_id = int(self.law_id.value)
            conn = sqlite3.connect('liberty_country.db')
            conn.row_factory = sqlite3.Row
            c = conn.cursor()

            c.execute("SELECT * FROM criminal_code WHERE id=?", (law_id,))
            law = c.fetchone()
            conn.close()

            if not law:
                await interaction.response.send_message("❌ Закон не найден!", ephemeral=True)
                return

            embed = discord.Embed(
                title=f"📜 Статья {law['article']}",
                description=law['description'],
                color=discord.Color.red()
            )
            embed.add_field(name="Min срок", value=f"{law['min_sentence']} лет", inline=True)
            embed.add_field(name="Max срок", value=f"{law['max_sentence']} лет", inline=True)

            await interaction.response.send_message(embed=embed, ephemeral=True)
        except ValueError:
            await interaction.response.send_message("❌ Номер должен быть числом!", ephemeral=True)
        except Exception as e:
            await interaction.response.send_message(f"❌ Ошибка: {str(e)}", ephemeral=True)


class WeaponBuyModal(discord.ui.Modal):
    """Покупка оружия"""
    def __init__(self):
        super().__init__(title="Купить оружие")
        self.weapon_id = discord.ui.TextInput(label="ID оружия", required=True)
        self.add_item(self.weapon_id)

    async def on_submit(self, interaction: discord.Interaction):
        try:
            weapon_id = int(self.weapon_id.value)
            conn = sqlite3.connect('liberty_country.db')
            conn.row_factory = sqlite3.Row
            c = conn.cursor()

            c.execute("SELECT * FROM weapons WHERE id=?", (weapon_id,))
            weapon = c.fetchone()

            if not weapon:
                await interaction.response.send_message("❌ Оружие не найдено!", ephemeral=True)
                conn.close()
                return

            c.execute("SELECT * FROM citizens WHERE discord_id=?", (str(interaction.user.id),))
            citizen = c.fetchone()

            if not citizen:
                await interaction.response.send_message("❌ Вы не зарегистрированы!", ephemeral=True)
                conn.close()
                return

            if citizen['cash'] < weapon['price']:
                await interaction.response.send_message(
                    f"❌ Недостаточно денег! Нужно ${weapon['price']}, у вас ${citizen['cash']}",
                    ephemeral=True
                )
                conn.close()
                return

            # Проверяем лицензию если нужна
            if citizen['licenses'] and 'оружие' not in citizen['licenses'].lower():
                await interaction.response.send_message("❌ Нет лицензии на оружие!", ephemeral=True)
                conn.close()
                return

            add_cash(interaction.user.id, -weapon['price'])
            await interaction.response.send_message(
                f"✅ {weapon['weapon_type']} куплено за ${weapon['price']}!",
                ephemeral=True
            )
            conn.close()

        except ValueError:
            await interaction.response.send_message("❌ ID должен быть числом!", ephemeral=True)
        except Exception as e:
            await interaction.response.send_message(f"❌ Ошибка: {str(e)}", ephemeral=True)


class HousesSearchModal(discord.ui.Modal):
    """Поиск домов"""
    def __init__(self):
        super().__init__(title="Поиск дома")
        self.district = discord.ui.TextInput(label="Район", placeholder="Downtown", required=True)
        self.max_price = discord.ui.TextInput(label="Макс цена (0=любая)", required=False)
        self.add_item(self.district)
        self.add_item(self.max_price)

    async def on_submit(self, interaction: discord.Interaction):
        try:
            district = self.district.value.strip()
            max_price = int(self.max_price.value) if self.max_price.value else 0

            conn = sqlite3.connect('liberty_country.db')
            conn.row_factory = sqlite3.Row
            c = conn.cursor()

            if district.lower() == 'все':
                query = "SELECT * FROM houses WHERE status='available'"
                params = []
            else:
                query = "SELECT * FROM houses WHERE status='available' AND district=?"
                params = [district]

            if max_price > 0:
                query += " AND price <= ?"
                params.append(max_price)

            query += " LIMIT 10"
            c.execute(query, params)
            houses = c.fetchall()
            conn.close()

            if not houses:
                await interaction.response.send_message("❌ Домов не найдено", ephemeral=True)
                return

            embed = discord.Embed(title="🏠 Доступные дома", color=discord.Color.green())
            for idx, house in enumerate(houses, 1):
                embed.add_field(
                    name=f"{idx}. {house['address']}",
                    value=f"Район: {house['district']}\nЦена: ${house['price']}",
                    inline=False
                )

            await interaction.response.send_message(embed=embed, ephemeral=True)
        except ValueError:
            await interaction.response.send_message("❌ Цена должна быть числом!", ephemeral=True)
        except Exception as e:
            await interaction.response.send_message(f"❌ Ошибка: {str(e)}", ephemeral=True)


# ==================== VIEW КЛАССЫ ====================

class LawSelectionView(discord.ui.View):
    """Выбор закона"""
    def __init__(self, laws_list):
        super().__init__()
        self.laws = laws_list

        for idx, law in enumerate(laws_list[:5]):
            button = discord.ui.Button(
                label=f"Статья {law['article']}",
                custom_id=f"law_{idx}",
                style=discord.ButtonStyle.blue
            )
            button.callback = self.select_law
            self.add_item(button)

    async def select_law(self, interaction: discord.Interaction):
        idx = int(interaction.data['custom_id'].split('_')[1])
        law = self.laws[idx]

        embed = discord.Embed(
            title=f"📜 Статья {law['article']}",
            description=law['description'],
            color=discord.Color.red()
        )
        embed.add_field(name="Min срок", value=f"{law['min_sentence']} лет", inline=True)
        embed.add_field(name="Max срок", value=f"{law['max_sentence']} лет", inline=True)

        await interaction.response.send_message(embed=embed, ephemeral=True)


class HousesSearchView(discord.ui.View):
    """Выбор дома"""
    def __init__(self, houses_list):
        super().__init__()
        self.houses = houses_list

        for idx, house in enumerate(houses_list[:5]):
            button = discord.ui.Button(
                label=f"ID {idx} - {house['address'][:20]}",
                custom_id=f"house_{idx}",
                style=discord.ButtonStyle.green
            )
            button.callback = self.select_house
            self.add_item(button)

    async def select_house(self, interaction: discord.Interaction):
        idx = int(interaction.data['custom_id'].split('_')[1])
        house = self.houses[idx]

        embed = discord.Embed(
            title=f"🏠 {house['address']}",
            color=discord.Color.green()
        )
        embed.add_field(name="Район", value=house['district'], inline=True)
        embed.add_field(name="Цена", value=f"${house['price']}", inline=True)
        embed.add_field(name="Аренда/день", value=f"${house['rent']}", inline=True)
        embed.add_field(name="Статус", value=house['status'], inline=False)

        await interaction.response.send_message(embed=embed, ephemeral=True)

class JobApplicationView(ui.View):
    def __init__(self, faction):
        super().__init__(timeout=None)
        self.faction = faction

    @ui.button(label="Подать заявку", style=ButtonStyle.primary, custom_id="job_apply_button")
    async def apply_button(self, interaction: discord.Interaction, button: ui.Button):
        citizen = get_citizen(interaction.user.id)
        if not citizen or not citizen['passport_issued']:
            await interaction.response.send_message("❌ У вас нет паспорта!", ephemeral=True)
            return

        conn = sqlite3.connect('liberty_country.db')
        c = conn.cursor()
        c.execute("SELECT * FROM job_applications WHERE citizen_id=? AND faction=? AND status='pending'",
                  (citizen['id'], self.faction))
        existing_application = c.fetchone()
        conn.close()

        if existing_application:
            await interaction.response.send_message("❌ Вы уже подали заявку в эту фракцию!", ephemeral=True)
            return

        apply_for_job(citizen['id'], self.faction)

        faction_channel = discord.utils.get(interaction.guild.channels, name=f"{self.faction.lower()}-анкеты")
        if faction_channel:
            embed = discord.Embed(
                title=f"📝 НОВАЯ ЗАЯВКА В {self.faction}",
                color=discord.Color.blue()
            )
            embed.add_field(name="Кандидат", value=f"{citizen['last_name']} {citizen['first_name']}", inline=False)
            embed.add_field(name="Discord", value=interaction.user.mention, inline=False)
            embed.set_footer(text="Дата подачи: " + datetime.now(timezone.utc).strftime("%d.%m.%Y %H:%M"))

            await faction_channel.send(embed=embed)
            await interaction.response.send_message(
                f"✅ Заявка в {self.faction} успешно подана! Ожидайте рассмотрения.",
                ephemeral=True
            )
        else:
            await interaction.response.send_message(
                "❌ Ошибка: канал для анкет фракции не найден!",
                ephemeral=True)
            


from discord import ui, ButtonStyle, Interaction, Embed

class BankViewWithButtons(ui.View):
    def __init__(self):
        super().__init__(timeout=180)

    @ui.button(label="Внести деньги", style=ButtonStyle.success, custom_id="bank_deposit")
    async def deposit_button(self, interaction: Interaction, button: ui.Button):
        class DepositModal(discord.ui.Modal):
            def __init__(self):
                super().__init__(title="Внесение средств")
            amount = discord.ui.TextInput(
                label="Сумма",
                placeholder="Введите сумму для внесения",
                style=1
            )

            async def on_submit(self_inner, interaction: Interaction):
                try:
                    amount_val = int(self_inner.amount.value)
                    if amount_val <= 0:
                        await interaction.response.send_message(
                            "❌ Сумма должна быть положительной!", ephemeral=True
                        )
                        return

                    citizen = get_citizen(interaction.user.id)
                    if not citizen:
                        await interaction.response.send_message(
                            "❌ У вас нет банковского счета!", ephemeral=True
                        )
                        return

                    if citizen['cash'] < amount_val:
                        await interaction.response.send_message(
                            f"❌ Недостаточно наличных! У вас: {citizen['cash']}$",
                            ephemeral=True
                        )
                        return

                    add_cash(interaction.user.id, -amount_val)
                    add_bank(interaction.user.id, amount_val)
                    log_transaction(interaction.user.id, "deposit", amount_val)

                    updated_citizen = get_citizen(interaction.user.id)

                    embed = Embed(
                        title="✅ СРЕДСТВА ВНЕСЕНЫ",
                        description=f"Вы внесли {amount_val}$ на банковский счет",
                        color=discord.Color.green()
                    )
                    embed.add_field(name="Наличные", value=f"💵 {updated_citizen['cash']}$", inline=True)
                    embed.add_field(name="Банк", value=f"🏦 {updated_citizen['bank']}$", inline=True)

                    await interaction.response.send_message(embed=embed, ephemeral=True)

                except ValueError:
                    await interaction.response.send_message(
                        "❌ Неверный формат суммы! Введите число.", ephemeral=True
                    )

        await interaction.response.send_modal(DepositModal())

    @ui.button(label="Снять деньги", style=ButtonStyle.danger, custom_id="bank_withdraw")
    async def withdraw_button(self, interaction: Interaction, button: ui.Button):
        class WithdrawModal(discord.ui.Modal):
            def __init__(self):
                super().__init__(title="Снятие средств")
            amount = discord.ui.TextInput(
                label="Сумма",
                placeholder="Введите сумму для снятия",
                style=1
            )

            async def on_submit(self_inner, interaction: Interaction):
                try:
                    amount_val = int(self_inner.amount.value)
                    if amount_val <= 0:
                        await interaction.response.send_message(
                            "❌ Сумма должна быть положительной!", ephemeral=True
                        )
                        return

                    citizen = get_citizen(interaction.user.id)
                    if not citizen:
                        await interaction.response.send_message(
                            "❌ У вас нет банковского счета!", ephemeral=True
                        )
                        return

                    if citizen['bank'] < amount_val:
                        await interaction.response.send_message(
                            f"❌ Недостаточно средств на счете! У вас: {citizen['bank']}$",
                            ephemeral=True
                        )
                        return

                    add_bank(interaction.user.id, -amount_val)
                    add_cash(interaction.user.id, amount_val)
                    log_transaction(interaction.user.id, "withdraw", amount_val)

                    updated_citizen = get_citizen(interaction.user.id)

                    embed = Embed(
                        title="✅ СРЕДСТВА СНЯТЫ",
                        description=f"Вы сняли {amount_val}$ с банковского счета",
                        color=discord.Color.green()
                    )
                    embed.add_field(name="Наличные", value=f"💵 {updated_citizen['cash']}$", inline=True)
                    embed.add_field(name="Банк", value=f"🏦 {updated_citizen['bank']}$", inline=True)

                    await interaction.response.send_message(embed=embed, ephemeral=True)

                except ValueError:
                    await interaction.response.send_message(
                        "❌ Неверный формат суммы! Введите число.", ephemeral=True
                    )

        await interaction.response.send_modal(WithdrawModal())


class AutoshopCategoryView(ui.View):
    def __init__(self):
        super().__init__(timeout=60)

    @ui.button(label="Sedan", style=discord.ButtonStyle.primary)
    async def sedan_callback(self, interaction: discord.Interaction, button: ui.Button):
        await self.show_category(interaction, "Sedan")

    @ui.button(label="SUV", style=discord.ButtonStyle.primary)
    async def suv_callback(self, interaction: discord.Interaction, button: ui.Button):
        await self.show_category(interaction, "SUV")

    @ui.button(label="Sports", style=discord.ButtonStyle.primary)
    async def sports_callback(self, interaction: discord.Interaction, button: ui.Button):
        await self.show_category(interaction, "Sports")

    @ui.button(label="Luxury", style=discord.ButtonStyle.primary)
    async def luxury_callback(self, interaction: discord.Interaction, button: ui.Button):
        await self.show_category(interaction, "Luxury")

    @ui.button(label="Truck", style=discord.ButtonStyle.primary)
    async def truck_callback(self, interaction: discord.Interaction, button: ui.Button):
        await self.show_category(interaction, "Truck")

    async def show_category(self, interaction: discord.Interaction, category: str):
        cars = CAR_DEALERSHIP.get(category, [])
        if not cars:
            await interaction.response.send_message(f"❌ В категории {category} нет автомобилей!", ephemeral=True)
            return

        embed = discord.Embed(
            title=f"🚗 АВТОМОБИЛИ КАТЕГОРИИ {category.upper()}",
            color=discord.Color.blue()
        )

        for car in cars:
            embed.add_field(
                name=f"{car['name']} - ${car['price']}",
                value=car['description'],
                inline=False
            )

        embed.set_footer(text="Для покупки используйте команду !купить_авто [модель] [цвет]")
        await interaction.response.send_message(embed=embed, ephemeral=True)

# Работа с базой данных
def get_citizen(user_id: int):
    conn = sqlite3.connect("liberty_country.db")
    conn.row_factory = sqlite3.Row
    c = conn.cursor()
    # Таблица citizens использует колонку discord_id для идентификации игрока.
    # Вместо user_id выбираем по discord_id. Сохраняем тип как строка для совместимости.
    c.execute("SELECT * FROM citizens WHERE discord_id = ?", (str(user_id),))
    result = c.fetchone()
    conn.close()
    return result

def delete_passport(user_id: int):
    conn = sqlite3.connect('liberty_country.db')
    c = conn.cursor()
    c.execute("UPDATE citizens SET passport_issued = 0 WHERE discord_id = ?", (user_id,))
    conn.commit()
    result = c.rowcount
    conn.close()
    return result > 0

def issue_passport(user_id, first_name, last_name, birth_date, birth_place, biography):
    conn = sqlite3.connect("liberty_country.db")
    c = conn.cursor()

    # Обновляем данные паспорта. В таблице citizens биография хранится в поле 'bio'.
    # При выдаче паспорта прописываем место жительства 'Отель' и дату гражданства.
    c.execute("""
        UPDATE citizens
        SET first_name=?, last_name=?, birth_date=?, birth_place=?,
            bio=?, passport_issued=1, residence='Отель',
            citizenship_date=DATE('now')
        WHERE discord_id=?
    """, (first_name, last_name, birth_date, birth_place, biography, user_id))

    conn.commit()
    conn.close()

def build_passport_embed(citizen):
    embed = discord.Embed(
        title="🛂 ВАШ ПАСПОРТ",
        description="Официальный документ гражданина штата",
        color=discord.Color.blue()
    )
    embed.add_field(name="Имя", value=citizen['first_name'], inline=True)
    embed.add_field(name="Фамилия", value=citizen['last_name'], inline=True)
    embed.add_field(name="Дата рождения", value=citizen['birth_date'], inline=True)
    embed.add_field(name="Место рождения", value=citizen['birth_place'], inline=True)
    embed.add_field(name="Гражданство", value="США" if "сша" in citizen['birth_place'].lower() else "Грин-карта", inline=True)
    embed.add_field(name="Место жительства", value=citizen['residence'], inline=True)
    embed.add_field(name="Дата выдачи", value=citizen['citizenship_date'], inline=True)
    embed.set_footer(text="Паспортный стол Калифорнии | Действует бессрочно")
    return embed
    


def add_cash(discord_id, amount):
    conn = sqlite3.connect('liberty_country.db')
    c = conn.cursor()
    c.execute("UPDATE citizens SET cash = cash + ? WHERE discord_id=?", (amount, str(discord_id)))
    conn.commit()
    conn.close()


def add_bank(discord_id, amount):
    conn = sqlite3.connect('liberty_country.db')
    c = conn.cursor()
    c.execute("UPDATE citizens SET bank = bank + ? WHERE discord_id=?", (amount, str(discord_id)))
    conn.commit()
    conn.close()


def set_cash(discord_id, amount):
    conn = sqlite3.connect('liberty_country.db')
    c = conn.cursor()
    c.execute("UPDATE citizens SET cash = ? WHERE discord_id=?", (amount, str(discord_id)))
    conn.commit()
    conn.close()


def set_bank(discord_id, amount):
    conn = sqlite3.connect('liberty_country.db')
    c = conn.cursor()
    c.execute("UPDATE citizens SET bank = ? WHERE discord_id=?", (amount, str(discord_id)))
    conn.commit()
    conn.close()


def create_citizen(discord_id, first_name, last_name, birth_date, birth_place, bio):
    restricted_words = ['мафиози', 'гопник', 'бандит', 'наркобарон', 'гангстер', 'гитлер', 'нацист']
    blocked_government = int(any(word in bio.lower() for word in restricted_words))

    conn = sqlite3.connect("liberty_country.db")
    c = conn.cursor()

    # Проверяем — уже существует?
    c.execute("SELECT id FROM citizens WHERE discord_id = ?", (discord_id,))
    existing = c.fetchone()

    if existing:
        # Обновляем существующего
        c.execute("""
            UPDATE citizens SET
                first_name=?, last_name=?, birth_date=?, birth_place=?,
                bio=?, blocked_government=?, passport_issued=1,
                citizenship_date=DATE('now')
            WHERE discord_id=?
        """, (first_name, last_name, birth_date, birth_place, bio, blocked_government, discord_id))
    else:
        # Создаём нового
        c.execute("""
            INSERT INTO citizens (
                discord_id, first_name, last_name, birth_date, birth_place,
                passport_issued, citizenship_date, bio, blocked_government
            ) VALUES (?, ?, ?, ?, ?, 1, DATE('now'), ?, ?)
        """, (discord_id, first_name, last_name, birth_date, birth_place, bio, blocked_government))

    conn.commit()
    conn.close()

    if blocked_government:
        return True, "📘 Паспорт выдан, но вы не можете поступать на госслужбу (неподходящая биография)."
    return True, "✅ Паспорт успешно выдан!"

def get_license_info(licenses):
    if not licenses:
        return "Отсутствуют"

    license_map = {
        "DL": "🚗 Водительское удостоверение",
        "CCW": "🔫 Лицензия на скрытое ношение",
        "PF": "🧯 Лицензия пожарного",
        "PI": "🕵️ Лицензия частного детектива",
        "EL": "⚡ Лицензия электрика",
        "PL": "🚰 Лицензия сантехника",
        "FI": "💰 Финансовая лицензия",
        "HR": "🎯 Охотничья лицензия",
        "SMG": "🔫 Лицензия на автоматическое оружие"
    }

    return "\n".join([license_map.get(lic, lic) for lic in licenses.split(",")])


# —— ВСТАВИТЬ ЗДЕСЬ среди других вспомогательных функций ——  


def add_tax(citizen_id, tax_type, amount):
    try:
        conn = sqlite3.connect('liberty_country.db', timeout=10)
        c = conn.cursor()

        # Точное время в формате UTC
        timestamp = datetime.now(timezone.utc).strftime("%Y-%m-%d %H:%M:%S")
        c.execute('''
            INSERT INTO taxes (citizen_id, type, amount, date)
            VALUES (?, ?, ?, ?)
        ''', (citizen_id, tax_type, amount, timestamp))

        conn.commit()
    except sqlite3.OperationalError as e:
        print(f"❌ [add_tax] Ошибка доступа к базе: {e}")
    finally:
        conn.close()


def get_governor_settings() -> Tuple[bool, float]:
    conn = sqlite3.connect('liberty_country.db')
    c = conn.cursor()
    c.execute("SELECT state_of_emergency, salary_modifier FROM governor WHERE id=1")
    soe, mod = c.fetchone()
    conn.close()
    return bool(soe), mod


def set_state_of_emergency(on: bool):
    conn = sqlite3.connect('liberty_country.db')
    c = conn.cursor()
    c.execute("UPDATE governor SET state_of_emergency=?, last_decree_date=? WHERE id=1",
              (1 if on else 0, datetime.now(timezone.utc).strftime("%Y-%m-%d %H:%M:%S")))
    conn.commit()
    conn.close()


def set_salary_modifier(mod: float):
    conn = sqlite3.connect('liberty_country.db')
    c = conn.cursor()
    c.execute("UPDATE governor SET salary_modifier=? WHERE id=1", (mod,))
    conn.commit()
    conn.close()


def apply_for_job(citizen_id, faction):
    conn = sqlite3.connect('liberty_country.db')
    c = conn.cursor()
    apply_date = datetime.now(timezone.utc).strftime("%d.%m.%Y %H:%M")
    c.execute("""
        INSERT INTO job_applications (citizen_id, faction, application_date)
        VALUES (?, ?, ?)
    """, (citizen_id, faction, apply_date))
    conn.commit()
    conn.close()


def add_weapon(owner_id, weapon_type, license_required):
    conn = sqlite3.connect('liberty_country.db')
    c = conn.cursor()
    serial = f"{random.randint(1000, 9999)}-{random.randint(10000, 99999)}"
    today = datetime.date.today().strftime("%d.%m.%Y")
    c.execute("""
        INSERT INTO weapons (owner_id, type, serial, license_required, purchase_date)
        VALUES (?, ?, ?, ?, ?)
    """, (owner_id, weapon_type, serial, license_required, today))
    conn.commit()
    conn.close()
    return serial


def add_vehicle(owner_id, model, color, year, car_type):
    conn = sqlite3.connect('liberty_country.db')
    c = conn.cursor()
    plate = f"{random.choice(['ABC', 'XYZ', 'CAL'])}-{random.randint(100, 999)}"
    c.execute("""
        INSERT INTO vehicles (owner_id, plate, model, color, year, type)
        VALUES (?, ?, ?, ?, ?, ?)
    """, (owner_id, plate, model, color, year, car_type))
    conn.commit()
    conn.close()
    return plate


def create_loan(citizen_id, amount, interest_rate, days):
    conn = sqlite3.connect('liberty_country.db')
    c = conn.cursor()
    taken_date = datetime.now(timezone.utc).strftime("%d.%m.%Y %H:%M")
    due_date = (datetime.now(timezone.utc) + datetime.timedelta(days=days)).strftime("%d.%m.%Y %H:%M")
    c.execute("""
        INSERT INTO loans (citizen_id, amount, interest_rate, taken_date, due_date)
        VALUES (?, ?, ?, ?, ?)
    """, (citizen_id, amount, interest_rate, taken_date, due_date))
    conn.commit()
    conn.close()


def pay_loan(loan_id, amount):
    conn = sqlite3.connect('liberty_country.db')
    c = conn.cursor()
    c.execute("UPDATE loans SET paid_amount = paid_amount + ? WHERE id=?", (amount, loan_id))

    c.execute("SELECT amount, paid_amount FROM loans WHERE id=?", (loan_id,))
    loan = c.fetchone()
    if loan and loan['paid_amount'] >= loan['amount']:
        c.execute("UPDATE loans SET status = 'paid' WHERE id=?", (loan_id,))

    conn.commit()
    conn.close()


def update_credit_score(discord_id, change):
    conn = sqlite3.connect('liberty_country.db')
    c = conn.cursor()
    c.execute("UPDATE citizens SET credit_score = credit_score + ? WHERE discord_id=?", (change, str(discord_id)))
    conn.commit()
    conn.close()


def update_credit_score_by_id(citizen_id, change):
    conn = sqlite3.connect('liberty_country.db')
    c = conn.cursor()
    c.execute("UPDATE citizens SET credit_score = credit_score + ? WHERE id=?", (change, citizen_id))
    conn.commit()
    conn.close()


def reset_work_count(discord_id):
    conn = None
    try:
        conn = sqlite3.connect('liberty_country.db')
        c = conn.cursor()
        c.execute("UPDATE citizens SET work_count = 0, last_work_real_time = ? WHERE discord_id=?",
                  (time.time(), str(discord_id)))
        conn.commit()
    except Exception as e:
        print(f"Error in work command: {e}")
        # Если вызывается не из async функции — убери эту строку:
        # await ctx.send("❌ Произошла ошибка при выполнении команды")
    finally:
        if conn:
            conn.close()

def get_game_time():
    now_real = datetime.now(timezone.utc)

    hours_since_epoch = (now_real - datetime(2025, 1, 1)).total_seconds() / 3600
    total_game_days = hours_since_epoch * REAL_HOUR_TO_GAME_DAY

    game_year = 2025 + int(total_game_days // 365)
    remaining_days = total_game_days % 365
    game_month = 1 + int(remaining_days // 30)
    game_day = 1 + int(remaining_days % 30)
    game_hour = int((remaining_days - int(remaining_days)) * 24)

    return game_year, game_month, game_day, game_hour


def format_game_time(year, month, day, hour):
    return f"{day:02d}.{month:02d}.{year} {hour:02d}:00"


def calculate_game_due_date(days):
    game_year, game_month, game_day, game_hour = get_game_time()
    game_days = days * 24
    total_days = game_day + game_days

    new_game_day = total_days % 30
    if new_game_day == 0:
        new_game_day = 30
    new_game_month = game_month + (total_days - 1) // 30
    new_game_year = game_year + (new_game_month - 1) // 12
    new_game_month = (new_game_month - 1) % 12 + 1

    return f"{int(new_game_day):02d}.{int(new_game_month):02d}.{int(new_game_year)}"


def can_work(discord_id):
    citizen = get_citizen(discord_id)
    if not citizen:
        return False

    current_time = time.time()
    last_work_time = citizen['last_work_real_time']

    if last_work_time == 0:
        return True

    # Рассчитываем сколько реального времени прошло с последней работы
    hours_passed = (current_time - last_work_time) / 3600

    # Проверяем, прошло ли достаточно времени для нового игрового дня
    if hours_passed >= (24 / REAL_HOUR_TO_GAME_DAY):
        return True

    return citizen['work_count'] < 5


def increment_work_count(discord_id):
    conn = None
    try:
        conn = sqlite3.connect('liberty_country.db')
        c = conn.cursor()
        c.execute("UPDATE citizens SET work_count = work_count + 1 WHERE discord_id=?",
                  (str(discord_id),))
        conn.commit()
    except Exception as e:
        print(f"❌ Ошибка при увеличении work_count: {e}")
    finally:
        if conn:
            conn.close()
def get_game_time():
    now_real = datetime.now(timezone.utc)

    hours_since_epoch = (now_real - datetime(2025, 1, 1)).total_seconds() / 3600
    total_game_days = hours_since_epoch * REAL_HOUR_TO_GAME_DAY

    game_year = 2025 + int(total_game_days // 365)
    remaining_days = total_game_days % 365
    game_month = 1 + int(remaining_days // 30)
    game_day = 1 + int(remaining_days % 30)
    game_hour = int((remaining_days - int(remaining_days)) * 24)

    return game_year, game_month, game_day, game_hour


def increment_work_count(discord_id):
    conn = sqlite3.connect('liberty_country.db')
    c = conn.cursor()
    c.execute("UPDATE citizens SET work_count = work_count + 1 WHERE discord_id=?", (str(discord_id),))
    conn.commit()
    conn.close()


# Автомобили и оружие
CAR_DEALERSHIP = {
    "Sedan": [
        {"name": "Leland Birchwood 1995", "price": 10000, "description": "Надежный универсал для семьи и путешествий"},
        {"name": "Chevlon Antelope 1994", "price": 8500, "description": "Классический седан"},
        {"name": "Chevlon Captain 2009", "price": 11850, "description": "Комфортный седан"},
        {"name": "Elysion Slick 2014", "price": 19000, "description": "Современный седан"},
        {"name": "Navara Imperium 2020", "price": 22500, "description": "Премиальный седан"},
        {"name": "Leland LTS 2010", "price": 27500, "description": "Представительский седан"},
        {"name": "Bullhorn Prancer 2011", "price": 18000, "description": "Спортивный седан"},
        {"name": "Bullhorn Prancer 2015", "price": 22000, "description": "Динамичный седан"},
        {"name": "2020 Averon RS3", "price": 32000, "description": "Спортивный седан"},
        {"name": "2021 Stuttgart Vierturig", "price": 38000, "description": "Немецкий инжиниринг"},
        {"name": "2023 Leland LTS5-V BLACKWING", "price": 65000, "description": "Мощный седан"},
        {"name": "2020 Bullhorn Prancer Widebody", "price": 42000, "description": "Широкий кузов"},
        {"name": "2010 Averon s5", "price": 28000, "description": "Классическое купе"}
    ],
    "SUV": [
        {"name": "Overland Apache 1995", "price": 9950, "description": "Внедорожник для бездорожья"},
        {"name": "Falcon Traveller 2003", "price": 12500, "description": "Универсальный кроссовер"},
        {"name": "Chevlon Camion 2008", "price": 28050, "description": "Практичный кроссовер"},
        {"name": "Chevlon Camion 2018", "price": 34500, "description": "Современный кроссовер"},
        {"name": "Falcon Scavenger 2016", "price": 39700, "description": "Внедорожник для приключений"},

        {"name": "Chevlon Revver 2005", "price": 40000, "description": "Мощный внедорожник"},
        {"name": "Overland Apache 2011", "price": 32000, "description": "Надежный кроссовер"},
        {"name": "Overland Buckaroo 2018", "price": 42000, "description": "Комфортный внедорожник"},
        {"name": "Vellfire Riptide 2020", "price": 48000, "description": "Динамичный SUV"},
        {"name": "Bullhorn Pueblo 2018", "price": 45000, "description": "Премиальный внедорожник"},
        {"name": "Chevlon Camion 2021", "price": 52000, "description": "Современный кроссовер"},
        {"name": "2020 BKM MUNICH", "price": 38000, "description": "Немецкое качество"},
        {"name": "2022 Terrain Traveller", "price": 41000, "description": "Для дальних путешествий"},
        {"name": "2022 Averon Q8", "price": 55000, "description": "Премиум внедорожник"},
        {"name": "2022 Stuttgart LandSchaft", "price": 58000, "description": "Люкс внедорожник"},
        {"name": "2020 Leland Vault", "price": 47000, "description": "Проходимый внедорожник"},
        {"name": "Falcon Rampage Beast", "price": 32000, "description": "Мощный внедорожник"},
        {"name": "2024 Falcon EStallion", "price": 62000, "description": "Электрический кроссовер"},
        {"name": "2024 Averon Anodic", "price": 68000, "description": "Электрический внедорожник"},
        {"name": "2024 Celesial Truckatron", "price": 72000, "description": "Электрический пикап"}
    ],
    "Sports": [
        {"name": "Chevlon Amigo LZR 2016", "price": 42000, "description": "Спортивное купе"},
        {"name": "Chevlon Amigo S 2016", "price": 45000, "description": "Динамичный спорткар"},
        {"name": "Chevlon Amigo LZR 2011", "price": 38000, "description": "Легендарный спорткар"},
        {"name": "Chevlon Amigo S 2011", "price": 36000, "description": "Классика спортивного дизайна"},
        {"name": "2013 Havara Horizon", "price": 55000, "description": "Эксклюзивный спорткар"},
        {"name": "2019 Vellfire Pioneer", "price": 58000, "description": "Современный спортивный автомобиль"},
        {"name": "2014 Chevlon Corbeta RZR", "price": 62000, "description": "Американская мощь"},
        {"name": "2023 Chevlon Corbeta 8", "price": 85000, "description": "Новое поколение"},
        {"name": "2021 Takeo experience", "price": 78000, "description": "Японский спорткар"},
        {"name": "2017 Averon R8", "price": 92000, "description": "Немецкая инженерия"},
        {"name": "2016 Surrey 650s", "price": 250000, "description": "Эксклюзивный гиперкар"},
        {"name": "2020 Strugatti Ettore", "price": 300000, "description": "Легенда гиперкаров"},
        {"name": "2022 Bullhorn Determinator SFP", "price": 280000, "description": "Экстремальная производительность"},
        {"name": "2020 BKM Risen Roadster", "price": 95000, "description": "Электрический спорткар"},
        {"name": "Chevlon Corbeza 2014 1M edition", "price": 68000, "description": "Ограниченная серия"},
        {"name": "Chevlon Corbeza X08 2014", "price": 75000, "description": "Трековая версия"},
        {"name": "Bullhorn Determinator SFP Fury 2022", "price": 320000, "description": "Самый быстрый в линейке"},
        {"name": "2023 Celestial Type 6", "price": 88000, "description": "Электрический хетчбек"}
    ],
    "Truck": [
        {"name": "Vellfire Evertt Extended CAD 1995", "price": 14500, "description": "Надежный пикап"},
        {"name": "Chevlon landslide 2007", "price": 19500, "description": "Рабочий пикап"},
        {"name": "bullhorn BH 15 2009", "price": 30500, "description": "Мощный грузовик"},
        {"name": "Navara Boundary 2022", "price": 42000, "description": "Современный пикап"},
        {"name": "Vellfire Everest VRD Max 2023", "price": 68000, "description": "Премиальный пикап"},
        {"name": "Chevlon Platoro 2019", "price": 52000, "description": "Универсальный грузовик"},

{"name": "Vellfire Prarie 2022", "price": 58000, "description": "Современный пикап"},
{"name": "Chevlon Commuter Van 2006", "price": 25000, "description": "Практичный минивэн"}
]
}
WEAPON_SHOP = {
    "BERETTA M9": {"price": 900, "license": "CCW", "description": "Стандартный служебный пистолет", "legal": True},
    "COLT 1911": {"price": 850, "license": "CCW", "description": "Классический пистолет", "legal": True},
    "DESERT EAGLE": {"price": 1400, "license": "CCW", "description": "Мощный пистолет", "legal": True},
    "TEC-9": {"price": 1100, "license": "CCW", "description": "Пистолет-пулемет", "legal": True},
    "REMINGTON 870": {"price": 1200, "license": "HR", "description": "Дробовик для охоты", "legal": True},
    "KRISS VECTOR": {"price": 3500, "license": "SMG", "description": "Автоматический пистолет-пулемет", "legal": True},
    "AK-47": {"price": 3000, "license": None, "description": "Автоматическая винтовка (НЕЛЕГАЛЬНАЯ)", "legal": False},
    "UZI": {"price": 2800, "license": None, "description": "Компактный пистолет-пулемет (НЕЛЕГАЛЬНАЯ)", "legal": False},
    "GLOCK 18": {"price": 1500, "license": None, "description": "Пистолет с режимом автомат (НЕЛЕГАЛЬНАЯ)",
                 "legal": False},
    "MOSSBERG 500": {"price": 1100, "license": None, "description": "Тактический дробовик (НЕЛЕГАЛЬНАЯ)",
                     "legal": False},
}

# Конфигурация бизнесов
BUSINESSES = {
    "tehstation": {
        "name": "🔧 Автосервис",
        "description": "Ремонт, тюнинг и диагностика автомобилей",
        "price": 500000,
        "income": 500
    },
    "clothstore": {
        "name": "👕 Магазин одежды",
        "description": "Модная одежда и аксессуары",
        "price": 300000,
        "income": 300
    },
    "jeweller": {
        "name": "💎 Ювелирный магазин",
        "description": "Драгоценности и украшения",
        "price": 1000000,
        "income": 1000
    },
    "restaurant": {
        "name": "🍽️ Ресторан",
        "description": "Изысканная кухня и напитки",
        "price": 800000,
        "income": 800
    },
    "hotel": {
        "name": "🏨 Отель",
        "description": "Комфортабельные номера для отдыха",
        "price": 1500000,
        "income": 1500
    },
    "gasstation": {
        "name": "⛽ Заправка",
        "description": "Топливо и сопутствующие товары",
        "price": 700000,
        "income": 700
    },
    "gunstore": {
        "name": "🔫 Оружейный магазин",
        "description": "Огнестрельное оружие и аксессуары",
        "price": 900000,
        "income": 900
    }
}


class BusinessView(ui.View):
    def init(self, business_id):
        super().init(timeout=180)
        self.business_id = business_id
        business = BUSINESSES[business_id]

        # Добавляем кнопки в зависимости от типа бизнеса
        self.add_item(ui.Button(
            style=ButtonStyle.green,
            label=f"🏢 Купить бизнес (${business['price']})",
            custom_id=f"buy_{business_id}"
        ))

    @ui.button(label="ℹ️ Информация", style=ButtonStyle.primary)
    async def info(self, interaction: discord.Interaction, button: ui.Button):
        business = BUSINESSES[self.business_id]
        embed = discord.Embed(
            title=f"🏢 {business['name']}",
            description=business['description'],
            color=discord.Color.blue()
        )
        embed.add_field(name="Стоимость", value=f"${business['price']}", inline=True)
        embed.add_field(name="Ежедневный доход", value=f"${business['income']}", inline=True)
        await interaction.response.send_message(embed=embed, ephemeral=True)

    @ui.button(label="🛠️ Управление бизнесом", style=ButtonStyle.grey)  # ✅ Исправленный отступ
    async def manage_button(self, interaction: discord.Interaction, button: ui.Button):
        await interaction.response.send_message(

            embed=discord.Embed(
                title="⚙️ УПРАВЛЕНИЕ БИЗНЕСОМ",
                description="Выберите действие для вашего бизнеса",
                color=discord.Color.blue()
            ),
            view=BusinessManagementView(self.business_id),
            ephemeral=True
        )

    async def buy_business(self, interaction: discord.Interaction, business_id):
        # ... остальной код без изменений
        citizen = get_citizen(interaction.user.id)
        if not citizen:
            await interaction.response.send_message("❌ У вас нет паспорта!", ephemeral=True)
            return

        business = BUSINESSES[business_id]

        if citizen['bank'] < business['price']:
            await interaction.response.send_message(
                f"❌ Недостаточно средств на счете! Нужно: {business['price']}$, у вас: {citizen['bank']}$",
                ephemeral=True
            )
            return

        conn = sqlite3.connect('liberty_country.db')
        c = conn.cursor()

        # Проверяем, есть ли уже такой бизнес
        c.execute("SELECT * FROM businesses WHERE business_id=?", (business_id,))
        existing = c.fetchone()

        if existing:
            await interaction.response.send_message("❌ Этот бизнес уже куплен!", ephemeral=True)
            conn.close()
            return

        # Покупка бизнеса
        today = datetime.now(timezone.utc).strftime("%Y-%m-%d %H:%M:%S")
        c.execute("""
            INSERT INTO businesses (business_id, name, type, owner_id, income, last_income_date)
            VALUES (?, ?, ?, ?, ?, ?)
        """, (business_id, business['name'], business_id, citizen['id'], business['income'], today))

        c.execute("UPDATE citizens SET bank = bank - ? WHERE id=?", (business['price'], citizen['id']))

        conn.commit()
        conn.close()

        embed = discord.Embed(
            title="🏢 ПОЗДРАВЛЯЕМ С ПОКУПКОЙ БИЗНЕСА!",
            description=f"Вы стали владельцем: {business['name']}",
            color=discord.Color.green()
        )
        embed.add_field(name="Стоимость", value=f"${business['price']}", inline=True)
        embed.add_field(name="Ежедневный доход", value=f"${business['income']}", inline=True)
        embed.set_footer(text="Доход будет начисляться ежедневно автоматически")

        await interaction.response.send_message(embed=embed, ephemeral=True)


@bot.hybrid_command(name='бизнесы')
async def list_businesses(ctx):
    embed = discord.Embed(
        title="🏢 ДОСТУПНЫЕ БИЗНЕСЫ",
        description="Инвестируйте в бизнес для получения пассивного дохода",
        color=discord.Color.gold()
    )

    for business_id, business in BUSINESSES.items():
        embed.add_field(
            name=f"{business['name']} - ${business['price']}",
            value=f"{business['description']}\nДоход: ${business['income']}/день",
            inline=False
        )

    embed.set_footer(text="Используйте !бизнес [тип] для подробной информации")
    await ctx.send(embed=embed) 


@bot.hybrid_command(name='бизнес')
async def business_details(ctx, business_type: str):
    business = BUSINESSES.get(business_type.lower())
    if not business:
        await ctx.send("❌ Такого бизнеса не существует! Посмотрите список: !бизнесы")
        return

    embed = discord.Embed(
        title=f"🏢 {business['name']}",
        description=business['description'],
        color=discord.Color.blue()
    )
    embed.add_field(name="Стоимость", value=f"${business['price']}", inline=True)
    embed.add_field(name="Ежедневный доход", value=f"${business['income']}", inline=True)

    await ctx.send(embed=embed, view=BusinessView(business_type.lower()))


@bot.hybrid_command(name='мой_бизнес')
async def my_business(ctx):
    citizen = get_citizen(ctx.author.id)
    if not citizen:
        await ctx.send("❌ У вас нет паспорта!")
        return

    conn = sqlite3.connect('liberty_country.db')
    conn.row_factory = sqlite3.Row
    c = conn.cursor()

    c.execute("SELECT * FROM businesses WHERE owner_id=?", (citizen['id'],))
    businesses = c.fetchall()
    conn.close()

    if not businesses:
        await ctx.send("❌ У вас нет бизнесов! Посмотрите доступные: !бизнесы")
        return

    embed = discord.Embed(
        title="🏢 ВАШИ БИЗНЕСЫ",
        description=f"Общее количество: {len(businesses)}",
        color=discord.Color.gold()
    )

    total_income = 0
    for business in businesses:
        embed.add_field(
            name=business['name'],
            value=f"Тип: {business['type']}\nДоход: ${business['income']}/день",
            inline=False
        )
        total_income += business['income']

    embed.add_field(name="Общий ежедневный доход", value=f"${total_income}", inline=False)
    await ctx.send(embed=embed)


class RenameModal(ui.Modal):
    def __init__(self, business_id: str):
        super().__init__(title="Изменение названия бизнеса")
        self.business_id = business_id

        self.new_name = ui.TextInput(
            label="Новое название",
            placeholder="Введите новое название бизнеса",
            style=1
        )
        self.add_item(self.new_name)

    async def on_submit(self, interaction: discord.Interaction):
        conn = sqlite3.connect('liberty_country.db')
        c = conn.cursor()
        c.execute(
            "UPDATE businesses SET name=? WHERE business_id=?",
            (self.new_name.value, self.business_id)
        )
        conn.commit()
        conn.close()
        await interaction.response.send_message(
            f"✅ Название бизнеса успешно изменено на: {self.new_name.value}",
            ephemeral=True
        )


class SalaryModal(discord.ui.Modal):
    def __init__(self, business_id):
        super().__init__(title="Настройка зарплат")
        self.business_id = business_id
        self.manager_salary = discord.ui.TextInput(label="Зарплата менеджера ($)", style=1)
        self.employee_salary = discord.ui.TextInput(label="Базовая зарплата сотрудников ($)", style=1)
        # Добавляем поля один раз
        self.add_item(self.manager_salary)
        self.add_item(self.employee_salary)

    async def on_submit(self, interaction: discord.Interaction):
        try:
            manager_sal = int(self.manager_salary.value)
            employee_sal = int(self.employee_salary.value)

            conn = sqlite3.connect('liberty_country.db')
            c = conn.cursor()
            c.execute("UPDATE business_employees SET salary=? WHERE business_id=? AND position='manager'",
                      (manager_sal, self.business_id))
            c.execute("UPDATE business_employees SET salary=? WHERE business_id=? AND position='employee'",
                      (employee_sal, self.business_id))
            conn.commit()
            conn.close()

            await interaction.response.send_message(
                f"✅ Зарплаты успешно обновлены!\nМенеджер: ${manager_sal}\nСотрудники: ${employee_sal}",
                ephemeral=True
            )
        except ValueError:
            await interaction.response.send_message("❌ Неверный формат суммы! Введите числа.", ephemeral=True)


class BusinessManagementView(ui.View):
    def __init__(self, business_id):
        super().__init__(timeout=180)
        self.business_id = business_id

    @ui.button(label="✏️ Изменить название", style=discord.ButtonStyle.primary)
    async def rename_button(self, interaction: discord.Interaction, button: ui.Button):
        await interaction.response.send_modal(RenameModal(self.business_id))

    @ui.button(label="💰 Настроить зарплату", style=discord.ButtonStyle.primary)
    async def salary_button(self, interaction: discord.Interaction, button: ui.Button):
        await interaction.response.send_modal(SalaryModal(self.business_id))

    @ui.button(label="👥 Управление персоналом", style=discord.ButtonStyle.primary)
    async def staff_button(self, interaction: discord.Interaction, button: ui.Button):
        conn = sqlite3.connect('liberty_country.db')
        conn.row_factory = sqlite3.Row
        c = conn.cursor()

        c.execute("SELECT * FROM businesses WHERE business_id=?", (self.business_id,))
        business = c.fetchone()

        c.execute("""
            SELECT c.id, c.first_name, c.last_name, e.position, e.salary
            FROM business_employees e
            JOIN citizens c ON e.employee_id = c.id
            WHERE e.business_id=?
        """, (self.business_id,))
        employees = c.fetchall()
        conn.close()

        embed = discord.Embed(
            title=f"👥 ПЕРСОНАЛ: {business['name']}",
            description="Список сотрудников вашего бизнеса",
            color=discord.Color.blue()
        )

        manager_count = 0
        employee_count = 0
        for emp in employees:
            position = "👔 Менеджер" if emp['position'] == 'manager' else "👷 Сотрудник"
            embed.add_field(
                name=f"{emp['first_name']} {emp['last_name']} (ID: {emp['id']})",
                value=f"{position} | 💰 ${emp['salary']}",
                inline=False
            )
            if emp['position'] == 'manager':
                manager_count += 1
            else:
                employee_count += 1

        embed.add_field(
            name="Статистика",
            value=f"Всего сотрудников: {len(employees)}\nМенеджеров: {manager_count}\nРаботников: {employee_count}",
            inline=False
        )

        view = StaffManagementView(self.business_id, employees)
        await interaction.response.send_message(embed=embed, view=view, ephemeral=True)

    @ui.button(label="💸 Получить доход", style=discord.ButtonStyle.success)
    async def income_button(self, interaction: discord.Interaction, button: ui.Button):
        conn = sqlite3.connect('liberty_country.db')
        c = conn.cursor()

        c.execute("SELECT last_income_date FROM businesses WHERE business_id=?", (self.business_id,))
        last_income = c.fetchone()[0]
        last_date = datetime.strptime(last_income, "%Y-%m-%d %H:%M:%S")

        if (datetime.now(timezone.utc) - last_date).days < 1:
            await interaction.response.send_message(
                "❌ Вы уже получали доход сегодня! Повторное получение возможно через 24 часа.",
                ephemeral=True
            )
            conn.close()
            return

        c.execute("SELECT income FROM businesses WHERE business_id=?", (self.business_id,))
        base_income = c.fetchone()[0]

        c.execute("SELECT COUNT(*) FROM business_employees WHERE business_id=?", (self.business_id,))
        employee_count = c.fetchone()[0]

        efficiency = max(0.5, 1.0 - (employee_count * 0.1))
        actual_income = int(base_income * efficiency)

        new_date = datetime.now(timezone.utc).strftime("%Y-%m-%d %H:%M:%S")
        c.execute("UPDATE businesses SET last_income_date=? WHERE business_id=?",
                  (new_date, self.business_id))

        c.execute("SELECT owner_id FROM businesses WHERE business_id=?", (self.business_id,))
        owner_id = c.fetchone()[0]
        c.execute("UPDATE citizens SET bank = bank + ? WHERE id=?", (actual_income, owner_id))

        conn.commit()
        conn.close()

        await interaction.response.send_message(
            f"✅ Получен доход: ${actual_income}\n"
            f"Эффективность: {efficiency * 100:.0f}% (сотрудников: {employee_count})",
            ephemeral=True
        )


class StaffManagementView(ui.View):
    def __init__(self, business_id, employees):
        super().__init__(timeout=180)
        self.business_id = business_id
        self.employees = employees
        self.add_item(StaffSelect(employees))


class StaffSelect(ui.Select):
    def __init__(self, employees):
        options = []
        for emp in employees:
            label = f"{emp['first_name']} {emp['last_name']} ({emp['id']})"
            options.append(discord.SelectOption(label=label, value=str(emp['id'])))

        super().__init__(
            placeholder="Выберите сотрудника для увольнения",
            min_values=1,
            max_values=1,
            options=options
        )

    async def callback(self, interaction: discord.Interaction):
        employee_id = int(self.values[0])
        conn = sqlite3.connect('liberty_country.db')
        c = conn.cursor()
        c.execute("DELETE FROM business_employees WHERE employee_id=?", (employee_id,))
        conn.commit()
        conn.close()

        await interaction.response.send_message(
            f"✅ Сотрудник ID {employee_id} был уволен",
            ephemeral=True
        )


# Команды бота
@bot.hybrid_command(name='mdt')
@commands.check(is_police)
async def activate_mdt(ctx):
    embed = discord.Embed(
        title="🚨 ПОЛИЦЕЙСКИЙ ТЕРМИНАЛ (MDT)",
        description="Доступные функции правоохранительных органов",
        color=discord.Color.blue()
    )
    embed.add_field(
        name="Розыскные действия",
        value="• Объявить в розыск\n• Снять с розыска\n• Пометить авто в угоне\n• Снять с угона\n• Выписать штраф",
        inline=False
    )
    embed.add_field(
        name="Поиск информации",
        value="• Поиск гражданина\n• Проверить транспорт\n• Проверить штрафы\n• Поиск статьи УК",
        inline=False
    )
    embed.set_footer(text="Система MDT Калифорнии | Только для сотрудников правоохранительных органов")

    await ctx.send(embed=embed, view=MDTView(), ephemeral=True)
    await ctx.message.delete()

@bot.hybrid_command(name='оружейный_магазин')
async def weapon_shop(ctx):
    embed = discord.Embed(
        title="🔫 ОРУЖЕЙНЫЙ МАГАЗИН 'LIBERTY COUNTRY ARMS'",
        description="Лицензированная продажа огнестрельного оружия",
        color=discord.Color.dark_grey()
    )

    # Категории оружия
    categories = {
        "Пистолеты": [],
        "Дробовики": [],
        "Пистолеты-пулеметы": [],
        "Винтовки": [],
        "Снайперские винтовки": []
    }

    # Распределение оружия по категориям
    for weapon, details in WEAPON_SHOP.items():
        if "BERETTA" in weapon or "COLT" in weapon or "DESERT" in weapon or "TEC" in weapon:
            categories["Пистолеты"].append((weapon, details))
        elif "REMINGTON 870" in weapon:
            categories["Дробовики"].append((weapon, details))
        elif "KRISS" in weapon or "SKORPION" in weapon:
            categories["Пистолеты-пулеметы"].append((weapon, details))
        elif "AK47" in weapon or "LMT" in weapon:
            categories["Винтовки"].append((weapon, details))
        else:
            categories["Снайперские винтовки"].append((weapon, details))

    # Формирование списка по категориям
    for category, weapons in categories.items():
        if weapons:
            weapons_list = []
            for weapon, details in weapons:
                legal_status = "✅ Легальное" if details['legal'] else "⚠️ Нелегальное"
                license_req = details['license'] if details['license'] else "Не требуется"
                weapons_list.append(
                    f"{weapon} - ${details['price']}\n"
                    f"> Статус: {legal_status}\n"
                    f"> Лицензия: {license_req}\n"
                    f"> {details['description']}"
                )

            embed.add_field(
                name=f"🔹 {category}",
                value="\n\n".join(weapons_list),
                inline=False
            )

    # Информация о лицензиях
    embed.add_field(
        name="📜 ТИПЫ ЛИЦЕНЗИЙ",
        value=(
            "• CCW - Лицензия на скрытое ношение\n"
            "• HR - Охотничья лицензия\n"
            "• SMG - Лицензия на автоматическое оружие\n\n"
            "⚠️ Нелегальное оружие может привести к уголовной ответственности!"
        ),
        inline=False
    )

    embed.set_footer(text="Для покупки используйте команду !купить_оружие [название]")
    await ctx.send(embed=embed)
    

class WeaponShopView(ui.View):
    def __init__(self):
        super().__init__(timeout=None)  # None с большой буквы

    @ui.button(label="🔫 Просмотреть каталог", style=ButtonStyle.primary, custom_id="weapon_catalog")
    async def catalog_button(self, interaction: Interaction, button: ui.Button):
        await interaction.response.defer()
        # Здесь вызываем функцию с правильным использованием send_message или followup.send
        await weapon_shop(interaction)  # Внутри weapon_shop надо использовать interaction.response или followup

    @ui.button(label="🛒 Купить оружие", style=ButtonStyle.success, custom_id="buy_weapon")
    async def buy_button(self, interaction: Interaction, button: ui.Button):
        modal = WeaponBuyModal()
        await interaction.response.send_modal(modal)


@bot.hybrid_command(name='init_weaponshop')
@commands.has_permissions(administrator=True)
async def init_weaponshop(ctx):
    embed = discord.Embed(
        title="🔫 ОРУЖЕЙНЫЙ МАГАЗИН 'LIBERTY COUNTRY ARMS'",
        description="Лицензированная продажа огнестрельного оружия",
        color=discord.Color.dark_grey()
    )
    await ctx.send(embed=embed, view=WeaponShopView())

@bot.hybrid_command(name='купить_оружие')
async def buy_weapon(ctx, название_оружия: str):
    citizen = get_citizen(ctx.author.id)
    if not citizen or not citizen['passport_issued']:
        await ctx.send("❌ У вас нет паспорта!")
        return

    # Поиск оружия по неполному названию
    weapon_name = None
    weapon_info = None

    for weapon, details in WEAPON_SHOP.items():
        if название_оружия.upper() in weapon.upper():
            weapon_name = weapon
            weapon_info = details
            break

    if not weapon_name or not weapon_info:
        await ctx.send("❌ Такого оружия нет в магазине! Посмотрите доступное: !оружельный_магазин")
        return

    # Проверка лицензии
    license_req = weapon_info['license']
    current_licenses = citizen['licenses'].split(",") if citizen['licenses'] else []

    if license_req and license_req not in current_licenses:
        await ctx.send(f"❌ Для покупки этого оружия требуется лицензия {license_req}!")
        return

    # Проверка баланса
    price = weapon_info['price']
    if citizen['cash'] < price:
        await ctx.send(f"❌ Недостаточно наличных! Стоимость: {price}$. Ваши наличные: {citizen['cash']}$")
        return

    # Покупка оружия
    serial = add_weapon(citizen['id'], weapon_name, license_req)
    add_cash(ctx.author.id, -price)

    # Формирование ответа
    embed = discord.Embed(
        title="🔫 ПОКУПКА ОРУЖИЯ",
        description=f"Вы приобрели {weapon_name}",
        color=discord.Color.dark_grey()
    )
    embed.add_field(name="Серийный номер", value=serial, inline=True)
    embed.add_field(name="Стоимость", value=f"${price}", inline=True)

    if weapon_info['legal']:
        embed.add_field(name="Статус", value="✅ Легальное оружие", inline=True)
    else:
        embed.add_field(name="⚠️ Внимание", value="Нелегальное оружие! Риск конфискации и уголовного преследования",
                        inline=False)
        embed.set_thumbnail(url="https://cdn-icons-png.flaticon.com/512/2786/2786392.png")

    embed.add_field(name="Новые наличные", value=f"💵 {citizen['cash'] - price}$", inline=False)
    embed.set_footer(text="Храните оружие в безопасном месте!")

    await ctx.send(embed=embed)


# Добавьте в раздел команд бота

@bot.hybrid_command(name='admin_panel')
@commands.check(is_owner)
async def admin_panel(ctx):
    embed = discord.Embed(
        title="👑 ПАНЕЛЬ АДМИНИСТРАТОРА",
        description="Доступные функции управления",
        color=discord.Color.gold()
    )
    embed.add_field(name="👤 Досье игрока", value="Просмотр полной информации об игроке", inline=False)
    embed.add_field(name="⛔ Блокировка", value="Блокировка игрока на сервере", inline=False)
    embed.add_field(name="✅ Разблокировка", value="Снятие блокировки с игрока", inline=False)
    embed.add_field(name="👑 Администратор", value="Назначение/снятие прав администратора", inline=False)
    embed.add_field(name="💸 Управление деньгами", value="Изменение баланса игрока", inline=False)

    await ctx.send(embed=embed, view=AdminPanelView())
    await ctx.message.delete()

import sqlite3
import discord
from discord.ext import commands, tasks

AUDIT_CHANNEL_ID = 1368332077996445727

async def log_audit(bot, message: str):
    channel = bot.get_channel(AUDIT_CHANNEL_ID)
    if channel:
        now = datetime.now(timezone.utc).strftime("%Y-%m-%d %H:%M:%S")
        embed = discord.Embed(
            title="🕵️ Аудит действия",
            description=message,
            color=0x2f3136
        )
        embed.set_footer(text=f"{now}")
        await channel.send(embed=embed)
    else:
        print(f"[AUDIT] {message} — ❌ Канал аудита не найден")

@bot.hybrid_command(name="init_hotel")
@commands.is_owner()
async def init_hotel(ctx):
    class HotelView(discord.ui.View):
        def __init__(self):
            super().__init__(timeout=None)

        @discord.ui.button(label="🏨 Получить номер (50$)", style=discord.ButtonStyle.primary, custom_id="get_hotel_room")
        async def get_room(self, interaction: discord.Interaction, button: discord.ui.Button):
            citizen = get_citizen(interaction.user.id)
            if not citizen:
                await interaction.response.send_message("❌ Вы не зарегистрированы как гражданин!", ephemeral=True)
                return

            if citizen["residence"] == "Отель":
                await interaction.response.send_message("❌ Вы уже проживаете в отеле.", ephemeral=True)
                return

            conn = sqlite3.connect("liberty_country.db")
            c = conn.cursor()

            c.execute("SELECT COUNT(*) FROM citizens WHERE residence = 'Отель'")
            occupied = c.fetchone()[0]
            free = 50 - occupied

            if free <= 0:
                await interaction.response.send_message("❌ Все номера заняты.", ephemeral=True)
                conn.close()
                return

            if citizen["bank"] < 50:
                await interaction.response.send_message("❌ Недостаточно средств на банковском счету (нужно 50$)", ephemeral=True)
                conn.close()
                return

            # Списание и обновление
            new_balance = citizen["bank"] - 50
            expire_time = datetime.now(timezone.utc) + timedelta(hours=1)

            c.execute("""
                UPDATE citizens 
                SET bank = ?, residence = 'Отель', hotel_expire = ?
                WHERE id = ?
            """, (new_balance, expire_time.isoformat(), citizen["id"]))

            conn.commit()
            conn.close()

            await interaction.response.send_message(f"✅ Вы успешно заселились в отель. Осталось свободных номеров: {free - 1}", ephemeral=True)
            await log_audit(bot, f"{interaction.user} заселился в отель до {expire_time.strftime('%H:%M:%S')}.")

    conn = sqlite3.connect("liberty_country.db")
    c = conn.cursor()
    c.execute("SELECT COUNT(*) FROM citizens WHERE residence = 'Отель'")
    occupied = c.fetchone()[0]
    conn.close()
    available = max(0, 50 - occupied)

    await ctx.send(f"🏨 Добро пожаловать в отель Калифорнии!\nСвободно номеров: **{available}/50**", view=HotelView())

import sqlite3
from discord.ext import tasks

@tasks.loop(minutes=4320)
async def check_hotel_expiration():
    now = datetime.now(timezone.utc)  # ✅ правильное получение текущего времени

    conn = sqlite3.connect("liberty_country.db")
    c = conn.cursor()

    # Получаем всех, кто живёт в отеле
    c.execute("SELECT id, hotel_until FROM citizens WHERE residence = 'Отель'")
    rows = c.fetchall()

    for citizen_id, hotel_until in rows:
        if not hotel_until:
            continue
        try:
            expire_time = datetime.fromisoformat(hotel_until).replace(tzinfo=timezone.utc)
        except Exception as e:
            print(f"[HOTEL] Ошибка обработки времени для {citizen_id}: {e}")
            continue

        if now >= expire_time:
            c.execute("UPDATE citizens SET residence = 'Бездомный', hotel_until = NULL WHERE id = ?", (citizen_id,))
            print(f"[HOTEL] Гражданин {citizen_id} выселен из отеля")

    conn.commit()
    conn.close()

@bot.hybrid_command(name="buy_hotel")
async def buy_hotel(ctx):
    citizen = get_citizen(ctx.author.id)
    if not citizen:
        await ctx.send("❌ Вы не зарегистрированы как гражданин.")
        return

    price = 5_000_000
    total_money = citizen['cash'] + citizen['bank']
    if total_money < price:
        await ctx.send(f"❌ У вас недостаточно средств для покупки отеля. Нужно {price}$")
        return

    conn = sqlite3.connect('liberty_country.db')
    c = conn.cursor()

    from_bank = min(citizen['bank'], price)
    from_cash = price - from_bank
    new_bank = citizen['bank'] - from_bank
    new_cash = citizen['cash'] - from_cash

    c.execute("UPDATE citizens SET cash=?, bank=? WHERE id=?", (new_cash, new_bank, citizen['id']))
    c.execute("UPDATE businesses SET owner_id=? WHERE business_id=?", (citizen['id'], "hotel_001"))
    conn.commit()
    conn.close()

    await ctx.send(f"🏨 Поздравляем, {ctx.author.mention}! Вы теперь владелец Калифорнийского отеля за {price}$")
    await log_audit(bot, f"{ctx.author} купил отель за {price}$")

@bot.hybrid_command(name='init_autoshop')
@commands.has_permissions(administrator=True)
async def init_autoshop(ctx):

    class AutoshopOpenButton(ui.View):
        def __init__(self):
            super().__init__(timeout=None)

        @ui.button(label="🚗 Открыть автосалон", style=discord.ButtonStyle.primary, custom_id="open_autoshop")
        async def autoshop_button(self, interaction: discord.Interaction, button: ui.Button):
            await interaction.response.send_message(
                embed=discord.Embed(
                    title="🏁 АВТОСАЛОН КАЛИФОРНИИ",
                    description="Выберите категорию автомобиля:",
                    color=discord.Color.blue()
                ),
                view=AutoshopCategoryView(),
                ephemeral=True
            )

    embed = discord.Embed(
        title="🏁 ДОБРО ПОЖАЛОВАТЬ В АВТОСАЛОН",
        description="Нажмите кнопку ниже чтобы просмотреть доступные автомобили",
        color=discord.Color.blue()
    )
    await ctx.send(embed=embed, view=AutoshopOpenButton())


@bot.hybrid_command(name='init_hospital')
@commands.has_permissions(administrator=True)
async def init_hospital(ctx):
    class MedicalLeaveModal(discord.ui.Modal):
        def __init__(self):
            super().__init__(title="Заявление на мед отпуск")
            duration = discord.ui.TextInput(label="Срок (дни)", style=1)
            reason = discord.ui.TextInput(label="Причина", style=2)

        async def on_submit(self, interaction: discord.Interaction):
            try:
                days = int(self.duration.value)
                if days <= 0 or days > 30:
                    await interaction.response.send_message("❌ Срок должен быть от 1 до 30 дней!", ephemeral=True)
                    return

                embed = discord.Embed(
                    title="✅ ЗАЯВКА НА МЕД ОТПУСК ПРИНЯТА",
                    description=f"Ваш отпуск на {days} дней одобрен",
                    color=discord.Color.green()
                )
                embed.add_field(name="Причина", value=self.reason.value, inline=False)
                await interaction.response.send_message(embed=embed, ephemeral=True)
            except ValueError:
                await interaction.response.send_message("❌ Неверный формат срока!", ephemeral=True)

    class HospitalView(ui.View):
        def __init__(self):
            super().__init__(timeout=None)

        @ui.button(label="📖 Получить мед книжку", style=discord.ButtonStyle.green, custom_id="get_medical_book")
        async def medical_book_button(self, interaction: discord.Interaction, button: ui.Button):
            citizen = get_citizen(interaction.user.id)
            if citizen and not citizen.get('medical_book'):
                conn = sqlite3.connect('liberty_country.db')
                c = conn.cursor()
                c.execute("UPDATE citizens SET medical_book=1 WHERE id=?", (citizen['id'],))
                conn.commit()
                conn.close()
                await interaction.response.send_message("✅ Медицинская книжка оформлена!", ephemeral=True)
            else:
                await interaction.response.send_message("❌ У вас уже есть мед книжка!", ephemeral=True)

        @ui.button(label="🏥 Взять мед отпуск", style=discord.ButtonStyle.primary, custom_id="medical_leave")
        async def medical_leave_button(self, interaction: discord.Interaction, button: ui.Button):
            await interaction.response.send_modal(MedicalLeaveModal())

    embed = discord.Embed(
        title="🏥 МЕДИЦИНСКИЙ ЦЕНТР КАЛИФОРНИИ",
        description="Здоровье наших граждан — наш приоритет",
        color=discord.Color.green()
    )
    await ctx.send(embed=embed, view=HospitalView())

@bot.hybrid_command(name='init_stola')
@commands.has_permissions(administrator=True)
async def init_stola(ctx):
    view = ui.View(timeout=None)

    # Кнопка Ремонт
    repair_button = ui.Button(label="🔧 Ремонт", style=discord.ButtonStyle.primary, custom_id="repair_car")
    async def repair_callback(interaction: discord.Interaction):
        modal = CarServiceModal("Ремонт")
        await interaction.response.send_modal(modal)
    repair_button.callback = repair_callback
    view.add_item(repair_button)

    # Кнопка Тюнинг
    tune_button = ui.Button(label="🎨 Тюнинг", style=discord.ButtonStyle.primary, custom_id="tune_car")
    async def tune_callback(interaction: discord.Interaction):
        modal = CarServiceModal("Тюнинг")
        await interaction.response.send_modal(modal)
    tune_button.callback = tune_callback
    view.add_item(tune_button)

    embed = discord.Embed(
        title="🔧 АВТОСЕРВИС LOS SANTOS",
        description="Профессиональный ремонт и тюнинг автомобилей",
        color=discord.Color.orange()
    )
    await ctx.send(embed=embed, view=view)


@bot.hybrid_command(name='init_stosanta')
@commands.has_permissions(administrator=True)
async def init_stosanta(ctx):
    view = ui.View(timeout=None)

    @view.add_item(ui.Button(label="🔧 Ремонт", style=ButtonStyle.primary, custom_id="santa_repair"))
    async def repair_button(interaction: discord.Interaction):
        modal = CarServiceModal("Ремонт (Santa)")
        await interaction.response.send_modal(modal)

    @view.add_item(ui.Button(label="🎨 Тюнинг", style=ButtonStyle.primary, custom_id="santa_tune"))
    async def tune_button(interaction: discord.Interaction):
        modal = CarServiceModal("Тюнинг (Santa)")
        await interaction.response.send_modal(modal)

    embed = discord.Embed(
        title="🔧 АВТОСЕРВИС SANTA MONICA",
        description="Премиум обслуживание автомобилей",
        color=discord.Color.blue()
    )
    await ctx.send(embed=embed, view=view)


class CarServiceModal(discord.ui.Modal):
    def __init__(self):
        super().__init__(title="Обслуживание автомобиля")
    plate = discord.ui.TextInput(label="Гос. номер", style=1)
    service_details = discord.ui.TextInput(label="Описание работ", style=2)

    def init(self, service_type):
        super().init(title=f"{service_type} автомобиля")
        self.service_type = service_type

    async def on_submit(self, interaction: discord.Interaction):
        # Здесь можно добавить логику обработки услуги
        embed = discord.Embed(
            title=f"🔧 ЗАКАЗ НА {self.service_type.upper()} ПРИНЯТ",
            description=f"Автомобиль {self.plate.value}",
            color=discord.Color.green()
        )
        embed.add_field(name="Детали работ", value=self.service_details.value, inline=False)
        await interaction.response.send_message(embed=embed, ephemeral=True)

@bot.hybrid_command(name='init_zaprav')
@commands.has_permissions(administrator=True)
async def init_zaprav(ctx):
    view = ui.View(timeout=None)

    # Кнопка "⛽ Заправить машину"
    refuel_button = ui.Button(label="⛽ Заправить машину", style=discord.ButtonStyle.primary, custom_id="refuel_car")

    async def refuel_callback(interaction: discord.Interaction):
        modal = RefuelModal()
        await interaction.response.send_modal(modal)

    refuel_button.callback = refuel_callback
    view.add_item(refuel_button)

    # Кнопка "🛒 Купить продукты"
    groceries_button = ui.Button(label="🛒 Купить продукты", style=discord.ButtonStyle.success, custom_id="buy_groceries")

    async def groceries_callback(interaction: discord.Interaction):
        embed = discord.Embed(
            title="🛒 МИНИ-МАРКЕТ",
            description="Выберите продукты:",
            color=discord.Color.green()
        )
        products = [
            {"name": "Бутылка воды", "price": 2},
            {"name": "Энергетик", "price": 5},
            {"name": "Бутерброд", "price": 7},
            {"name": "Чипсы", "price": 4},
            {"name": "Шоколадный батончик", "price": 3}
        ]
        for product in products:
            embed.add_field(name=product["name"], value=f"${product['price']}", inline=True)

        await interaction.response.send_message(embed=embed, ephemeral=True)

    groceries_button.callback = groceries_callback
    view.add_item(groceries_button)

    embed = discord.Embed(
        title="⛽ ЗАПРАВОЧНАЯ СТАНЦИЯ",
        description="Топливо и продукты 24/7",
        color=discord.Color.red()
    )
    await ctx.send(embed=embed, view=view)


class RefuelModal(discord.ui.Modal):
    def __init__(self):
        super().__init__(title="Заправка автомобиля")
    plate = discord.ui.TextInput(label="Гос. номер", style=1)
    fuel_amount = discord.ui.TextInput(label="Количество литров", style=1)

    async def on_submit(self, interaction: discord.Interaction):
        try:
            liters = float(self.fuel_amount.value)
            if liters <= 0:
                raise ValueError

            cost = liters * 1.5  # $1.5 за литр
            citizen = get_citizen(interaction.user.id)

            if citizen and citizen['cash'] >= cost:
                add_cash(interaction.user.id, -cost)
                embed = discord.Embed(
                    title="⛽ ЗАПРАВКА ЗАВЕРШЕНА",
                    description=f"Заправлено {liters} литров",
                    color=discord.Color.green()
                )
                embed.add_field(name="Стоимость", value=f"${cost:.2f}", inline=False)
                embed.add_field(name="Новые наличные", value=f"💵 {citizen['cash'] - cost}$", inline=False)
            else:
                embed = discord.Embed(
                    title="❌ ОШИБКА ЗАПРАВКИ",
                    description="Недостаточно средств или гражданин не найден",
                    color=discord.Color.red()
                )

        except ValueError:
            embed = discord.Embed(
                title="❌ ОШИБКА",
                description="Неверное количество топлива. Введите положительное число.",
                color=discord.Color.red()
            )

        await interaction.response.send_message(embed=embed, ephemeral=True)

@bot.hybrid_command(name='init_bank')
@commands.has_permissions(administrator=True)
async def init_bank(ctx):
    embed = discord.Embed(
        title="🏦 БАНК КАЛИФОРНИИ",
        description="Полный спектр банковских услуг",
        color=discord.Color.gold()
    )

    view = BankViewWithButtons()

    # Кнопка "Купить дом"
    house_button = ui.Button(label="🏠 Купить дом", style=ButtonStyle.green)

    async def house_callback(interaction: discord.Interaction):
        await list_houses(interaction)

    house_button.callback = house_callback
    view.add_item(house_button)

    # Кнопка "Купить бизнес"
    business_button = ui.Button(label="🏢 Купить бизнес", style=ButtonStyle.green)

    async def business_callback(interaction: discord.Interaction):
        await list_businesses(interaction)

    business_button.callback = business_callback
    view.add_item(business_button)

    # Кнопка "Продать бизнес"
    sell_business_button = ui.Button(label="🏢 Продать бизнес", style=ButtonStyle.red)

    async def sell_business_callback(interaction: discord.Interaction):
        citizen = get_citizen(interaction.user.id)
        if not citizen:
            await interaction.response.send_message("❌ У вас нет паспорта!", ephemeral=True)
            return

        conn = sqlite3.connect('liberty_country.db')
        conn.row_factory = sqlite3.Row
        c = conn.cursor()
        c.execute("SELECT * FROM businesses WHERE owner_id=?", (citizen['id'],))
        businesses = c.fetchall()

        if not businesses:
            await interaction.response.send_message("❌ У вас нет бизнесов!", ephemeral=True)
            return

        options = []
        id_to_price = {}
        for business in businesses:
            options.append(discord.SelectOption(
                label=business['name'],
                value=str(business['id'])
            ))
            id_to_price[business['id']] = business['price']

        class BusinessSelect(ui.Select):
            def __init__(self):
                super().__init__(placeholder="Выберите бизнес для продажи", options=options)

            async def callback(self, interaction: discord.Interaction):
                business_id = int(self.values[0])
                refund = id_to_price[business_id] * 0.7

                conn = sqlite3.connect('liberty_country.db')
                c = conn.cursor()
                c.execute("DELETE FROM businesses WHERE id=?", (business_id,))
                add_bank(interaction.user.id, refund)
                conn.commit()
                conn.close()

                embed = discord.Embed(
                    title="✅ БИЗНЕС ПРОДАН",
                    description=f"Вы продали бизнес",
                    color=discord.Color.green()
                )
                embed.add_field(name="Получено", value=f"${refund:.2f}", inline=False)
                await interaction.response.send_message(embed=embed, ephemeral=True)

        select_view = ui.View(timeout=60)
        select_view.add_item(BusinessSelect())
        await interaction.response.send_message("Выберите бизнес для продажи:", view=select_view, ephemeral=True)

    sell_business_button.callback = sell_business_callback
    view.add_item(sell_business_button)

    await ctx.send(embed=embed, view=view)


@bot.hybrid_command(name='мойид')
async def my_id(ctx):
    citizen = get_citizen(ctx.author.id)
    if not citizen:
        await ctx.send("❌ У вас нет паспорта!")
        return

    embed = discord.Embed(
        title="🆔 ВАШ ID",
        description="Используйте этот ID для банковских переводов",
        color=discord.Color.blue()
    )
    embed.add_field(name="ID гражданина", value=citizen['id'], inline=False)
    embed.add_field(name="Discord ID", value=ctx.author.id, inline=False)
    await ctx.send(embed=embed)


import discord
import sqlite3

import discord
from discord.ext import commands
import sqlite3

# 👁 Класс модального окна "Заявка на паспорт"
class PassportApplication(discord.ui.Modal, title="Заявка на паспорт"):
    def __init__(self):
        super().__init__(timeout=None)

        # Создаём поля (не добавляем их повторно)
        self.last_name = discord.ui.TextInput(label="Фамилия", placeholder="Введите вашу фамилию")
        self.first_name = discord.ui.TextInput(label="Имя", placeholder="Введите ваше имя")
        self.age = discord.ui.TextInput(label="Возраст", placeholder="Укажите ваш возраст", max_length=2)
        self.bio = discord.ui.TextInput(label="Краткая биография", style=2, max_length=300)
        self.is_usa_born = discord.ui.TextInput(label="Вы родились в США?", placeholder="Да / Нет", max_length=10)

        # Добавляем поля один раз — итого 5 полей (максимум допустимый)
        self.add_item(self.last_name)
        self.add_item(self.first_name)
        self.add_item(self.age)
        self.add_item(self.bio)
        self.add_item(self.is_usa_born)

    async def on_submit(self, interaction: discord.Interaction):
        user_id = str(interaction.user.id)
        conn = sqlite3.connect("liberty_country.db")
        conn.row_factory = sqlite3.Row
        c = conn.cursor()

        # Проверка: паспорт уже есть?
        c.execute("SELECT * FROM citizens WHERE user_id = ?", (user_id,))
        if c.fetchone():
            await interaction.response.send_message("❌ У вас уже есть паспорт.", ephemeral=True)
            conn.close()
            return

        # Проверка на запрещённые слова
        banned_words = ['мафиози', 'гопник', 'бандит', 'наркобарон', 'гангстер', 'гитлер', 'нацист', 'fuck', 'сука', 'пидор', 'хуй']
        blocked = any(word in self.bio.value.lower() for word in banned_words)

        try:
            c.execute("""
                INSERT INTO citizens (
                    user_id, first_name, last_name, age, bio, is_usa_born,
                    blocked_government, hotel_until, passport_issued
                ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?)
            """, (
                user_id,
                self.first_name.value.strip(),
                self.last_name.value.strip(),
                int(self.age.value.strip()),
                self.bio.value.strip(),
                1 if self.is_usa_born.value.strip().lower() == "да" else 0,
                int(blocked),
                None,
                1
            ))
            conn.commit()
        except Exception as e:
            await interaction.response.send_message(f"❌ Ошибка базы данных: {e}", ephemeral=True)
            conn.close()
            return
        finally:
            conn.close()

        # Выдача роли
        role = discord.utils.get(interaction.guild.roles, name="『👨‍🦱』Civilian American")
        if role:
            try:
                await interaction.user.add_roles(role)
            except Exception as e:
                print(f"Ошибка при выдаче роли: {e}")

        # Установка ника
        try:
            nick = f"{self.last_name.value.strip()} {self.first_name.value.strip()}"
            await interaction.user.edit(nick=nick[:32])
        except Exception as e:
            print(f"Ошибка при установке ника: {e}")

        msg = "✅ Паспорт успешно выдан!"
        if blocked:
            msg = "✅ Паспорт выдан, но вам **запрещён доступ** в гос. органы."
        await interaction.response.send_message(msg, ephemeral=True)
        
@bot.hybrid_command(name='паспорт')
async def view_passport(ctx, member: discord.Member = None):
    target = member or ctx.author
    citizen = get_citizen(target.id)
    if not citizen or not citizen['passport_issued']:
        await ctx.send("❌ У пользователя нет паспорта!")
        return

    is_usa_born = "сша" in citizen['birth_place'].lower() or "usa" in citizen['birth_place'].lower()

    # Получаем бизнесы пользователя
    conn = sqlite3.connect('liberty_country.db')
    c = conn.cursor()
    c.execute("SELECT name FROM businesses WHERE owner_id=?", (citizen['id'],))
    businesses = c.fetchall()
    business_list = ", ".join([b[0] for b in businesses]) if businesses else "Нет бизнесов"
    conn.close()

    embed = discord.Embed(
        title=f"🛂 ПАСПОРТ {citizen['last_name']} {citizen['first_name']}",
        description="Официальный документ, удостоверяющий личность",
        color=discord.Color.gold() if not is_usa_born else discord.Color.blue()
    )
    embed.add_field(name="Фамилия", value=citizen['last_name'], inline=True)
    embed.add_field(name="Имя", value=citizen['first_name'], inline=True)
    embed.add_field(name="Дата рождения", value=citizen['birth_date'], inline=True)
    embed.add_field(name="Место рождения", value=citizen['birth_place'], inline=True)
    embed.add_field(name="Место жительства", value=citizen['residence'], inline=True)
    embed.add_field(name="Гражданство", value="США" if is_usa_born else "Грин-карта", inline=True)
    embed.add_field(name="ID гражданина", value=citizen['id'], inline=True)
    embed.add_field(name="Мед. книжка", value="✅ Присутствует" if citizen['medical_book'] else "❌ Отсутствует",
                    inline=True)
    embed.add_field(name="Лицензии", value=get_license_info(citizen['licenses']), inline=True)
    embed.add_field(name="Место работы", value=citizen['job'], inline=True)
    embed.add_field(name="Бизнесы", value=business_list, inline=False)
    embed.add_field(name="Дата выдачи", value=citizen['citizenship_date'], inline=False)
    embed.add_field(name="Баланс", value=f"💵 {citizen['cash']}$ 🏦 {citizen['bank']}$", inline=False)
    embed.set_footer(text="Паспортный стол Калифорнии | Действителен бессрочно")

    await ctx.send(embed=embed)


@bot.hybrid_command(name='изменить_имя')
async def change_name_command(ctx, новое_имя: str, новая_фамилия: str):
    citizen = get_citizen(ctx.author.id)
    if not citizen or not citizen['passport_issued']:
        await ctx.send("❌ У вас нет паспорта!")
        return

    cost = 50000
    if citizen['cash'] < cost:
        await ctx.send(
            f"❌ Недостаточно средств! Стоимость: {cost}$. Ваши финансы: 💵 {citizen['cash']}$ 🏦 {citizen['bank']}$")
        return

    change_name(citizen['id'], новое_имя, новая_фамилия, cost)

    embed = discord.Embed(
        title="✅ ИЗМЕНЕНИЕ ПАСПОРТНЫХ ДАННЫХ",
        description="Ваше имя и фамилия успешно изменены",
        color=discord.Color.green()
    )
    embed.add_field(name="Старое имя", value=f"{citizen['last_name']} {citizen['first_name']}", inline=False)
    embed.add_field(name="Новое имя", value=f"{новая_фамилия} {новое_имя}", inline=False)
    embed.add_field(name="Стоимость", value=f"💵 {cost}$", inline=True)
    embed.add_field(name="Новый баланс", value=f"💵 {citizen['cash'] - cost}$", inline=True)
    embed.set_footer(text=f"Изменено: {datetime.now(timezone.utc).strftime('%d.%m.%Y %H:%M')}")

    await ctx.send(embed=embed)


@bot.hybrid_command(name='список_работ')
async def list_jobs(ctx):
    embed = discord.Embed(
        title="💼 ДОСТУПНЫЕ ПРОФЕССИИ",
        description="Для устройства на работу используйте команду !устроиться_на_работу [профессия]",
        color=discord.Color.gold()
    )

    for job, details in CIVIL_JOBS.items():
        if job == "безработный":
            continue

        reqs = ", ".join(details["requirements"]) if details["requirements"] else "Отсутствуют"
        salary_range = f"{details['salary'][0]}-{details['salary'][1]}$"

        embed.add_field(
            name=f"{job.capitalize()}",
            value=(
                f"> 📝 {details['description']}\n"
                f"> 💰 Зарплата: {salary_range}\n"
                f"> 📜 Требования: {reqs}"
            ),
            inline=False
        )

    embed.set_footer(text="Центр занятости Калифорнии")
    await ctx.send(embed=embed)


@bot.hybrid_command(name='устроиться_на_работу')
async def get_civil_job(ctx, профессия: str):
    citizen = get_citizen(ctx.author.id)
    if not citizen or not citizen['passport_issued']:
        await ctx.send("❌ У вас нет паспорта!")
        return

    профессия = профессия.lower()
    if профессия not in CIVIL_JOBS and профессия not in ["LCPD", "LCSD", "LAFD", "DOJ"]:
        await ctx.send("❌ Такой профессии не существует!")
        return

    job_info = CIVIL_JOBS.get(профессия, {})

    current_licenses = citizen['licenses'].split(",") if citizen['licenses'] else []
    for req in job_info.get("requirements", []):
        if req not in current_licenses:
            license_names = {
                "DL": "водительское удостоверение (DL)",
                "CCW": "лицензия на оружие (CCW)",
                "EL": "лицензия электрика (EL)",
                "PL": "лицензия сантехника (PL)",
                "FI": "финансовая лицензия (FI)"
            }
            await ctx.send(f"❌ Для этой работы требуется {license_names.get(req, req)}!")
            return

    conn = sqlite3.connect('liberty_country.db')
    c = conn.cursor()
    c.execute("UPDATE citizens SET job = ? WHERE id = ?", (профессия, citizen['id']))
    conn.commit()
    conn.close()

    if профессия in ["LCPD", "LCSD", "LAFD", "DOJ"]:
        role = discord.utils.get(ctx.guild.roles, name=профессия)
        if not role:
            role = await ctx.guild.create_role(name=профессия)
        await ctx.author.add_roles(role)

    job_names = {
        "LCPD": "👮 Полиция Лос-Анджелеса",
        "LCSD": "👮‍♂️ Офис шерифа округа Лос-Анджелес",
        "LAFD": "🧑‍🚒 Пожарная служба Лос-Анджелеса",
        "DOJ": "⚖️ Министерство юстиции"
    }

    await ctx.send(f"✅ Вы успешно устроились на работу: {job_names.get(профессия, профессия.capitalize())}")

    await ctx.send("❌ Ошибка при устройстве на работу")


# —— ВСТАВИТЬ ЗДЕСЬ среди публичных команд ——  

@bot.hybrid_command(name='чп')
@commands.check(lambda ctx: ctx.author.id in owner_id)
async def announce_emergency(ctx):
    soe, _ = get_governor_settings()
    if not soe:
        return await ctx.send("⚠️ ЧП не объявлено.")
    chan = discord.utils.get(ctx.guild.channels, name="общий")
    if chan:
        await chan.send("@here 🚨 ЧП — ношение оружия разрешено для LEO!")
    await ctx.send("✅ Сигнал ЧП отправлен.", ephemeral=True)


@bot.hybrid_command(name='уволиться')
async def quit_job(ctx):
    citizen = get_citizen(ctx.author.id)
    if not citizen or not citizen['passport_issued']:
        await ctx.send("❌ У вас нет паспорта!")
        return

    if citizen['job'] == 'безработный':
        await ctx.send("❌ Вы уже безработный!")
        return

    conn = sqlite3.connect('liberty_country.db')
    c = conn.cursor()
    c.execute("UPDATE citizens SET job = 'безработный' WHERE id = ?", (citizen['id'],))
    conn.commit()
    conn.close()

    if citizen['job'] in ["LCPD", "LCSD", "LAFD", "DOJ"]:
        role = discord.utils.get(ctx.guild.roles, name=citizen['job'])
        if role:
            await ctx.author.remove_roles(role)

    await ctx.send("✅ Вы успешно уволились с работы!")


@bot.hybrid_command(name='работать')
async def work(ctx):
    citizen = get_citizen(ctx.author.id)
    if not citizen or not citizen['passport_issued']:
        await ctx.send("❌ У вас нет паспорта!")
        return

    if citizen['job'] == 'безработный':
        await ctx.send("❌ Вы не устроены на работу! Посмотрите доступные профессии: !список_работ")
        return

    if not can_work(ctx.author.id):
        _, _, _, current_hour = get_game_time()
        hours_left = 24 - current_hour
        real_minutes_left = int(hours_left / REAL_HOUR_TO_GAME_DAY * 60)

        embed = discord.Embed(
            title="⏳ ПРЕВЫШЕН ЛИМИТ РАБОТЫ",
            description="Вы уже отработали максимальное количество смен за сегодня",
            color=discord.Color.orange()
        )
        embed.add_field(
            name="Ограничения",
            value=(
                "• Максимум 5 рабочих смен в игровой день\n"
                f"• Новые смены будут доступны через {real_minutes_left} минут"
            ),
            inline=False
        )
        await ctx.send(embed=embed)
        return

    # Сбрасываем счётчик, если это первая смена за день
    if citizen['work_count'] == 0:
        reset_work_count(ctx.author.id)

    # Определяем базовый заработок
    failure = None
    job_info = CIVIL_JOBS.get(citizen['job'], {"salary": (50, 100)})
    if random.random() < 0.1 and 'failures' in job_info and job_info['failures']:
        failure = random.choice(job_info['failures'])
        earnings = 0
        account = None
    else:
        if citizen['job'] in ['LCPD', 'LCSD', 'LAFD', 'DOJ']:
            earnings = random.randint(200, 300)
            account = 'bank'
        else:
            salary_min, salary_max = job_info["salary"]
            earnings = random.randint(salary_min, salary_max)
            account = 'cash'

    # Применяем множитель зарплат и страховку
    soe, mod = get_governor_settings()
    earnings = int(earnings * mod)
    if soe and citizen['job'] in ['LCPD', 'LCSD', 'LAFD', 'DOJ']:
        earnings = int(earnings * 1.5)

    insurance = int(earnings * 0.10)
    net = earnings - insurance

    # Начисляем чистыми
    if account == 'bank':
        add_bank(ctx.author.id, net)
    elif account == 'cash':
        add_cash(ctx.author.id, net)

    # Фиксируем налог‑страховку
    add_tax(citizen['id'], 'insurance', insurance)

    # Увеличиваем счётчик смен
    increment_work_count(ctx.author.id)
    updated = get_citizen(ctx.author.id)

    # Текущее игровое время
    gy, gm, gd, gh = get_game_time()
    game_time_str = format_game_time(gy, gm, gd, gh)

    # Формируем embed‑ответ
    embed = discord.Embed(title="💼 РЕЗУЛЬТАТ РАБОЧЕЙ СМЕНЫ", color=discord.Color.gold())

    if failure:
        embed.description = f"⛔ ПРОИЗОШЛА НЕУДАЧА!\n{failure}"
        embed.set_thumbnail(url="https://cdn-icons-png.flaticon.com/512/521/521385.png")
    else:
        embed.description = (
            f"✅ УСПЕШНАЯ СМЕНА на должности **{citizen['job'].capitalize()}**\n"
            f"Заработано: **{earnings}$**\n"
            f"Чистыми: **{net}$**\n"
            f"Налог (страховка): **{insurance}$**"
        )
        embed.set_thumbnail(url="https://cdn-icons-png.flaticon.com/512/3135/3135810.png")

    embed.add_field(name="Осталось смен", value=f"{5 - updated['work_count']}/5", inline=True)
    embed.add_field(name="Игровое время", value=game_time_str, inline=False)

    embed.add_field(
        name="Новые финансы",
        value=(
            f"💵 Наличные: {updated['cash']}$\n"
            f"🏦 Банк: {updated['bank']}$"
        ),
        inline=False
    )

    await ctx.send(embed=embed)


@bot.hybrid_command(name='init_business')
async def init_business(ctx):
    citizen = get_citizen(ctx.author.id)
    if not citizen:
        await ctx.send("❌ У вас нет паспорта!")
        return

    conn = sqlite3.connect('liberty_country.db')
    conn.row_factory = sqlite3.Row
    c = conn.cursor()

    # Получаем бизнесы пользователя
    c.execute("SELECT * FROM businesses WHERE owner_id=?", (citizen['id'],))
    businesses = c.fetchall()
    conn.close()

    if not businesses:
        await ctx.send("❌ У вас нет бизнесов! Купите бизнес: !бизнесы")
        return

    view = ui.View(timeout=180)

    for business in businesses:
        business_id = business['business_id']
        button = ui.Button(
            style=ButtonStyle.primary,
            label=f"🛠️ {business['name']}",
            custom_id=f"manage_{business_id}"
        )

        async def make_callback(b_id):  # создаём обёртку, чтобы избежать замыкания
            async def business_callback(interaction: discord.Interaction):
                await interaction.response.send_message(
                    embed=discord.Embed(
                        title=f"⚙️ УПРАВЛЕНИЕ БИЗНЕСОМ",
                        description=f"Выберите действие для бизнеса с ID {b_id}",
                        color=discord.Color.blue()
                    ),
                    view=BusinessManagementView(b_id),
                    ephemeral=True
                )
            return business_callback

        button.callback = await make_callback(business_id)
        view.add_item(button)

    # Кнопка для покупки нового бизнеса
    buy_button = ui.Button(
        style=ButtonStyle.green,
        label="➕ Купить новый бизнес",
        custom_id="buy_new_business"
    )

    async def buy_callback(interaction: discord.Interaction):
        await interaction.response.send_message(
            "Для покупки нового бизнеса используйте команду: !бизнесы",
            ephemeral=True
        )

    buy_button.callback = buy_callback
    view.add_item(buy_button)

    await ctx.send(
        embed=discord.Embed(
            title="🏢 ВАШИ БИЗНЕСЫ",
            description="Выберите бизнес для управления",
            color=discord.Color.gold()
        ),
        view=view
    )

@bot.hybrid_command(name='время')
async def check_time(ctx):
    year, month, day, hour = get_game_time()
    time_str = format_game_time(year, month, day, hour)

    real_hours_per_day = 1 / REAL_HOUR_TO_GAME_DAY
    real_minutes_per_hour = real_hours_per_day * 60

    embed = discord.Embed(
        title="🕒 ИГРОВОЕ ВРЕМЯ",
        color=discord.Color.blue()
    )
    embed.add_field(name="Текущая дата", value=time_str, inline=False)
    embed.add_field(name="Временной масштаб",
                    value=f"1 реальный час = {REAL_HOUR_TO_GAME_DAY} игровых дней\n"
                          f"1 игровой день = {real_minutes_per_hour:.1f} реальных минут",
                    inline=False)

    await ctx.send(embed=embed)


@bot.hybrid_command(name='купить_авто')
async def buy_car(ctx, модель: str, цвет: str):
    try:
        citizen = get_citizen(ctx.author.id)
        if not citizen or not citizen['passport_issued']:
            await ctx.send("❌ У вас нет паспорта!")
            return

        # Поиск автомобиля по неполному названию
        found_car = None
        car_category = None

        for category, cars in CAR_DEALERSHIP.items():
            for car in cars:
                if модель.lower() in car['name'].lower():
                    found_car = car
                    car_category = category
                    break
            if found_car:
                break

        if not found_car:
            await ctx.send("❌ Автомобиль не найден! Посмотрите доступные в автосалоне: !автосалон")
            return

        # Проверка баланса
        price = found_car['price']
        if citizen['cash'] < price:
            await ctx.send(f"❌ Недостаточно наличных! Стоимость: {price}$. Ваши наличные: {citizen['cash']}$")
            return

        # Добавление автомобиля в базу
        year = random.randint(1990, 2023)
        plate = add_vehicle(citizen['id'], found_car['name'], цвет, year, car_category)

        # Списание средств
        add_cash(ctx.author.id, -price)

        # Формирование ответа
        embed = discord.Embed(
            title="🚗 ПОЗДРАВЛЯЕМ С ПОКУПКОЙ АВТОМОБИЛЯ!",
            description=f"Вы приобрели {found_car['name']}",
            color=discord.Color.green()
        )
        embed.add_field(name="Модель", value=found_car['name'], inline=True)
        embed.add_field(name="Цвет", value=цвет, inline=True)
        embed.add_field(name="Год выпуска", value=year, inline=True)
        embed.add_field(name="Категория", value=car_category, inline=True)
        embed.add_field(name="Гос. номер", value=plate, inline=True)
        embed.add_field(name="Стоимость", value=f"${price}", inline=True)
        embed.add_field(name="Новые наличные", value=f"💵 {citizen['cash'] - price}$", inline=False)
        embed.set_footer(text="Регистрация в базу данных LCPD произведена автоматически")

        await ctx.send(embed=embed)

    except Exception as e:
        await ctx.send("❌ Произошла ошибка при обработке покупки автомобиля")
        print(f"Ошибка при покупке авто: {e}")


@bot.hybrid_command(name='мои_штрафы')
async def my_fines(ctx):
    citizen = get_citizen(ctx.author.id)
    if not citizen or not citizen['passport_issued']:
        await ctx.send("❌ У вас нет паспорта!")
        return

    conn = sqlite3.connect('liberty_country.db')
    c = conn.cursor()
    c.execute("SELECT * FROM fines WHERE citizen_id=?", (citizen['id'],))
    fines = c.fetchall()
    conn.close()

    embed = discord.Embed(
        title="📋 ВАШИ ШТРАФЫ",
        color=discord.Color.orange()
    )

    if not fines:
        embed.description = "✅ У вас нет штрафов!"
    else:
        total_debt = 0
        for fine in fines:
            status = "✅ Оплачен" if fine['paid'] else f"❌ Не оплачен (до {fine['due_date']})"
            embed.add_field(
                name=f"Штраф #{fine['id']} - {fine['amount']}$",
                value=f"Причина: {fine['reason']}\nДата: {fine['issue_date']}\nСтатус: {status}",
                inline=False
            )
            if not fine['paid']:
                total_debt += fine['amount']

        if total_debt > 0:
            embed.add_field(
                name="Общая задолженность",
                value=f"💵 {total_debt}$",
                inline=False
            )
            embed.add_field(
                name="Оплатить штрафы",
                value="Используйте команду !оплатить_штраф [номер]",
                inline=False
            )

    await ctx.send(embed=embed)


@bot.hybrid_command(name='оплатить_штраф')
async def pay_fine(ctx, fine_id: int):
    citizen = get_citizen(ctx.author.id)
    if not citizen or not citizen['passport_issued']:
        await ctx.send("❌ У вас нет паспорта!")
        return

    conn = sqlite3.connect('liberty_country.db')
    c = conn.cursor()
    c.execute("SELECT * FROM fines WHERE id=? AND citizen_id=?", (fine_id, citizen['id']))
    fine = c.fetchone()

    if not fine:
        await ctx.send("❌ Штраф не найден!")
        conn.close()
        return

    if fine['paid']:
        await ctx.send("✅ Этот штраф уже оплачен!")
        conn.close()
        return

    amount = fine['amount']
    if citizen['cash'] < amount:
        await ctx.send(f"❌ Недостаточно наличных! Стоимость: {amount}$. Ваши наличные: {citizen['cash']}$")
        conn.close()
        return

    add_cash(ctx.author.id, -amount)
    c.execute("UPDATE fines SET paid=1 WHERE id=?", (fine_id,))
    conn.commit()
    conn.close()

    embed = discord.Embed(
        title="✅ ШТРАФ ОПЛАЧЕН",
        description=f"Вы оплатили штраф #{fine_id} на сумму {amount}$",
        color=discord.Color.green()
    )
    embed.add_field(name="Новые наличные", value=f"💵 {citizen['cash'] - amount}$", inline=False)
    await ctx.send(embed=embed)

# Централизованная функция регистрации гражданина


# Модальное окно Discord UI


import discord
import sqlite3
from discord import ui

class PassportView(discord.ui.View):
    def __init__(self, citizen_id=None):
        super().__init__(timeout=None)
        self.citizen_id = citizen_id

        if self.citizen_id is None:
            self.add_item(self.GetPassportButton())
            self.add_item(self.ViewPassportButton())
        else:
            self.add_item(self.ViewPassportButton(citizen_id=self.citizen_id))

    class GetPassportButton(discord.ui.Button):
        def __init__(self):
            super().__init__(
                label="🟢 Получить паспорт",
                style=discord.ButtonStyle.success,
                custom_id="get_passport"
            )

        async def callback(self, interaction: discord.Interaction):
            try:
                conn = sqlite3.connect("liberty_country.db")
                conn.row_factory = sqlite3.Row
                c = conn.cursor()
                c.execute("SELECT * FROM citizens WHERE user_id = ?", (str(interaction.user.id),))
                citizen = c.fetchone()
                conn.close()
            except Exception as e:
                await interaction.response.send_message(f"❌ Ошибка БД: {e}", ephemeral=True)
                return

            if citizen and citizen["passport_issued"]:
                await interaction.response.send_message("✅ У вас уже есть паспорт.", ephemeral=True)
            else:
                await interaction.response.send_modal(PassportApplication())

    class ViewPassportButton(discord.ui.Button):
        def __init__(self, citizen_id=None):
            super().__init__(
                label="📄 Посмотреть паспорт",
                style=discord.ButtonStyle.primary,
                custom_id="view_passport"
            )
            self.citizen_id = citizen_id

        async def callback(self, interaction: discord.Interaction):
            try:
                conn = sqlite3.connect("liberty_country.db")
                conn.row_factory = sqlite3.Row
                c = conn.cursor()

                if self.citizen_id:
                    c.execute("SELECT * FROM citizens WHERE id = ?", (self.citizen_id,))
                else:
                    c.execute("SELECT * FROM citizens WHERE user_id = ?", (str(interaction.user.id),))
                citizen = c.fetchone()
                conn.close()
            except Exception as e:
                await interaction.response.send_message(f"❌ Ошибка БД: {e}", ephemeral=True)
                return

            if not citizen:
                await interaction.response.send_message("❌ Паспорт не найден.", ephemeral=True)
                return

            if not int(citizen["passport_issued"]):
                await interaction.response.send_message("❌ У вас ещё нет паспорта.", ephemeral=True)
                return

            embed = discord.Embed(title="Паспорт гражданина США", color=0x3498db)
            embed.add_field(name="Имя", value=citizen["first_name"], inline=True)
            embed.add_field(name="Фамилия", value=citizen["last_name"], inline=True)
            embed.add_field(name="Возраст", value=citizen["age"], inline=True)
            embed.add_field(name="Биография", value=citizen["bio"] or "—", inline=False)
            embed.add_field(name="Место проживания", value=citizen["residence"] or "—", inline=True)
            embed.add_field(name="Рождён в США?", value="Да" if citizen["is_usa_born"] else "Нет", inline=True)
            embed.set_footer(text=f"ID гражданина: {citizen['id']}")

            await interaction.response.send_message(embed=embed, ephemeral=True)
                

@bot.hybrid_command(name="setup_passport")
@commands.is_owner()
async def setup_passport(ctx):
    embed = discord.Embed(
        title="🛂 Паспортный стол Калифорнии",
        description=(
            "Здесь вы можете:\n"
            "🟢 Получить паспорт\n"
            "📄 Посмотреть паспорт\n\n"
            "⚠️ Биография не должна содержать запрещённые слова. "
            "В противном случае вы не сможете попасть в гос. структуры."
        ),
        color=discord.Color.dark_blue()
    )
    embed.set_footer(text="Liberty Country State Bot • Паспортная система")
    await ctx.send(embed=embed, view=PassportView())


@bot.hybrid_command(name='setup_job_board')
@commands.has_permissions(administrator=True)
async def setup_job_board(ctx, faction: str):
    valid_factions = ["LCPD", "LCSD", "LAFD", "DOJ"]

    if faction.upper() not in valid_factions:
        await ctx.send(f"❌ Неверная фракция! Допустимые: {', '.join(valid_factions)}")
        return

    embed = discord.Embed(
        title=f"📋 ДОСКА ОБЪЯВЛЕНИЙ {faction.upper()}",
        description="Для подачи заявки на работу в государственную фракцию нажмите кнопку ниже",
        color=discord.Color.dark_blue()
    )
    embed.add_field(
        name="Требования",
        value="• Наличие паспорта\n• Отсутствие судимостей\n• Соответствие возрастным требованиям",
        inline=False
    )
    embed.set_footer(text="Кадровая служба Калифорнии")

    await ctx.send(embed=embed, view=JobApplicationView(faction.upper()))
    await ctx.message.delete()


@bot.hybrid_command(name='reset_user')
@commands.is_owner()
async def reset_user_command(ctx, member: discord.Member):
    conn = sqlite3.connect('liberty_country.db')
    c = conn.cursor()

    c.execute("DELETE FROM citizens WHERE discord_id=?", (str(member.id),))
    c.execute("DELETE FROM vehicles WHERE owner_id IN (SELECT id FROM citizens WHERE discord_id=?)", (str(member.id),))
    c.execute("DELETE FROM weapons WHERE owner_id IN (SELECT id FROM citizens WHERE discord_id=?)", (str(member.id),))
    c.execute("DELETE FROM loans WHERE citizen_id IN (SELECT id FROM citizens WHERE discord_id=?)", (str(member.id),))
    c.execute("DELETE FROM name_changes WHERE citizen_id IN (SELECT id FROM citizens WHERE discord_id=?)",
              (str(member.id),))
    c.execute("DELETE FROM job_applications WHERE citizen_id IN (SELECT id FROM citizens WHERE discord_id=?)",
              (str(member.id),))
    c.execute("DELETE FROM nicknames WHERE user_id=?", (str(member.id),))

    conn.commit()
    conn.close()

    roles_to_remove = [
        '『🪪』Гражданин Америки',
        '『🪪』Грин-карта',
        'LCPD', 'LCSD', 'LAFD', 'DOJ'
    ]

    for role_name in roles_to_remove:
        role = discord.utils.get(ctx.guild.roles, name=role_name)
        if role and role in member.roles:
            await member.remove_roles(role)

    embed = discord.Embed(
        title="♻️ СБРОС ДАННЫХ ИГРОКА",
        description=f"Все данные игрока {member.display_name} были полностью удалены",
        color=discord.Color.red()
    )
    embed.set_footer(text=f"Инициировано: {ctx.author.display_name}")

    await ctx.send(embed=embed)


@bot.hybrid_command(name='помощь')
async def help_command(ctx):
    embed = discord.Embed(
        title="🆘 СПРАВКА ПО КОМАНДАМ БОТА",
        description="Все доступные команды сгруппированы по категориям",
        color=discord.Color.blue()
    )

    # Основные команды
    embed.add_field(
        name="🪪 ОСНОВНЫЕ КОМАНДЫ",
        value=(
            "!паспорт - Показать ваш паспорт\n"
            "!изменить_имя [новое_имя] [новая_фамилия] - Сменить имя/фамилию (50,000$)\n"
            "!список_работ - Показать доступные профессии\n"
            "!устроиться_на_работу [профессия] - Устроиться на работу\n"
            "!уволиться - Уволиться с текущей работы\n"
            "!работать - Отработать смену\n"
            "!время - Показать игровое время\n"
            "!мойид - Показать ваш ID для переводов"
        ),
        inline=False
    )

    # Финансы и банк
    embed.add_field(
        name="💰 ФИНАНСЫ И БАНК",
        value=(
            "!банк - Открыть банковское меню с кнопками\n"
            "!автосалон - Просмотреть доступные автомобили\n"
            "!оружейный_магазин - Просмотреть доступное оружие"
        ),
        inline=False
    )

    # Транспорт и имущество
    embed.add_field(
        name="🚗 ТРАНСПОРТ И ОРУЖИЕ",
        value=(
            "!купить_авто [модель] [цвет] - Купить автомобиль\n"
            "!купить_оружие [название] - Купить оружие"
        ),
        inline=False
    )

    # Государственные службы
    embed.add_field(
        name="🏛️ ГОСУДАРСТВЕННЫЕ СЛУЖБЫ",
        value=(
            "!mdt - Полицейский терминал (только для LEO)\n"
            "!получить_медкнижку - Получить медицинскую книжку"
        ),
        inline=False
    )

    # Административные команды (только для владельца)
    if ctx.author.id in owner_id:
        embed.add_field(
            name="⚙️ АДМИНИСТРАТИВНЫЕ КОМАНДЫ",
            value=(
                "!add_cash [@пользователь] [сумма] - Добавить наличные\n"
                "!add_bank [@пользователь] [сумма] - Добавить деньги в банк\n"
                "!remove_cash [@пользователь] [сумма] - Убрать наличные\n"
                "!remove_bank [@пользователь] [сумма] - Убрать деньги из банка\n"
                "!reset_user [@пользователь] - Полный сброс данных игрока\n"
                "!setup_passport - Инициализация паспортного стола\n"
                "!setup_job_board [фракция] - Инициализация доски объявлений"
            ),
            inline=False
        )

    embed.set_footer(text="Бот RP-сервера Калифорнии | Полный список команд")
    await ctx.send(embed=embed)


# Автоматические задачи
@tasks.loop(minutes=5.0)
async def automatic_income():
    conn = sqlite3.connect('liberty_country.db')
    c = conn.cursor()

    c.execute("SELECT discord_id, business FROM citizens WHERE business IS NOT NULL")
    business_owners = c.fetchall()

    for owner in business_owners:
        add_bank(owner['discord_id'], 200)

    conn.close()


import discord
from discord.ext import commands
import sqlite3

# ID канала, куда логируются нарушения
WARN_LOG_CHANNEL_ID = 123456789012345678  # 🔧 ЗАМЕНИ на ID канала #нарушения

# Расширенный фильтр плохих слов
class WarnLogView(discord.ui.View):
    def __init__(self, user_id, reason):
        super().__init__(timeout=None)
        self.user_id = user_id
        self.reason = reason

    @discord.ui.button(label="Удалить варн", style=discord.ButtonStyle.danger, custom_id="remove_warn")
    async def remove_warn(self, interaction: discord.Interaction, button: discord.ui.Button):
        if not interaction.user.guild_permissions.administrator:
            await interaction.response.send_message("У вас нет прав для удаления варнов.", ephemeral=True)
            return

        conn = sqlite3.connect('infractions.db')
        c = conn.cursor()
        c.execute("SELECT warns FROM warns WHERE user_id = ?", (self.user_id,))
        result = c.fetchone()

        if result and result[0] > 0:
            new_warns = result[0] - 1
            c.execute("UPDATE warns SET warns = ? WHERE user_id = ?", (new_warns, self.user_id))
            conn.commit()
            await interaction.response.send_message(f"Варн удалён. Текущее количество: {new_warns}", ephemeral=True)
        else:
            await interaction.response.send_message("Нет варнов для удаления.", ephemeral=True)

        conn.close()


    
@bot.hybrid_command(name="варны")
@commands.has_permissions(administrator=True)
async def check_warns(ctx, member: discord.Member):
    conn = sqlite3.connect('infractions.db')
    c = conn.cursor()
    c.execute("SELECT warns FROM warns WHERE user_id = ?", (member.id,))
    result = c.fetchone()
    conn.close()

    warns = result[0] if result else 0
    await ctx.send(f"🔍 У {member.mention} {warns} предупреждений.")


@bot.hybrid_command(name="снять_варн")
@commands.has_permissions(administrator=True)
async def remove_warn(ctx, member: discord.Member):
    conn = sqlite3.connect('infractions.db')
    c = conn.cursor()
    c.execute("SELECT warns FROM warns WHERE user_id = ?", (member.id,))
    result = c.fetchone()

    if result and result[0] > 0:
        new_warns = result[0] - 1
        c.execute("UPDATE warns SET warns = ? WHERE user_id = ?", (new_warns, member.id))
        conn.commit()
        await ctx.send(f"✅ У {member.mention} удалён 1 варн. Теперь у него {new_warns} варн(ов).")
    else:
        await ctx.send(f"❌ У {member.mention} нет варнов или не найден в базе.")

    conn.close()


@bot.hybrid_command(name="сброс_варнов")
@commands.has_permissions(administrator=True)
async def reset_warns(ctx, member: discord.Member):
    conn = sqlite3.connect('infractions.db')
    c = conn.cursor()
    c.execute("DELETE FROM warns WHERE user_id = ?", (member.id,))
    conn.commit()
    conn.close()

    await ctx.send(f"🧹 Все предупреждения у {member.mention} были сброшены.")
    
   
import discord
from discord.ext import commands
import re
import os

AUDIT_CHANNEL_ID = 1398030452303855839

@bot.hybrid_command(name="анализ")
@commands.has_permissions(administrator=True)
async def analyze_articles(ctx):
    await ctx.send("🔍 Начинаю анализ последних 100 сообщений...")

    try:
        messages = [message async for message in ctx.channel.history(limit=100)]
        content = "\n".join(message.content for message in messages)

        # Ищем статьи в формате **18.1**
        found_articles = re.findall(r"\*\*(\d{1,2}\.\d{1,2})\*\*", content)
        unique_articles = sorted(set(found_articles))

        if not unique_articles:
            await ctx.send("❌ Статьи не найдены в последних 100 сообщениях.")
            return

        # Создание файла с результатами анализа
        filename = f"analyze_{ctx.channel.id}.txt"
        with open(filename, "w", encoding="utf-8") as f:
            f.write(f"Анализ канала: {ctx.channel.name}\n")
            f.write(f"Дата: {datetime.now(timezone.utc).strftime('%d.%m.%Y %H:%M')}\n")
            f.write(f"Найдено статей: {len(unique_articles)}\n")
            f.write("Список статей: " + ", ".join(unique_articles) + "\n\n")
            f.write("Фрагменты статей:\n\n")

            for article in unique_articles:
                pattern = rf"\*\*{re.escape(article)}\*\*.*?(?=\n\*\*|\Z)"
                match = re.search(pattern, content, re.DOTALL)
                if match:
                    f.write(match.group(0).strip() + "\n\n")

        # Отправка файла в канал аудита
        audit_channel = bot.get_channel(AUDIT_CHANNEL_ID)
        if audit_channel:
            await audit_channel.send(
                content=f"📁 **Файл анализа канала {ctx.channel.mention}** (вложение):",
                file=discord.File(filename)
            )

            # Также отправим Embed с краткой инфой
            embed = discord.Embed(
                title="📊 Аудит анализа",
                description=f"**Анализ завершён в канале:** {ctx.channel.mention}",
                color=discord.Color.green(),
                timestamp=datetime.now(timezone.utc)
            )
            embed.add_field(name="Автор", value=ctx.author.mention, inline=True)
            embed.add_field(name="Найдено статей", value=str(len(unique_articles)), inline=True)
            embed.set_footer(text="Система анализа УК")

            await audit_channel.send(embed=embed)

        # Ответ пользователю
        await ctx.send("✅ Анализ завершён. Файл был передан в аудит и защищён от удаления.")

        # Удаляем файл с устройства (в аудит он уже отправлен)
        try:
            os.remove(filename)
        except Exception as e:
            print(f"⚠️ Не удалось удалить файл: {e}")

    except Exception as e:
        await ctx.send(f"❌ Произошла ошибка при анализе: {e}")

@bot.hybrid_command(name="найти")
@commands.has_permissions(administrator=True)
async def find_article(ctx, article_number: str):
    filename = f"analyze_{ctx.channel.id}.txt"

    if not os.path.exists(filename):
        await ctx.send("❌ Файл анализа не найден. Сначала запустите `!анализ`.")
        return

    with open(filename, "r", encoding="utf-8") as f:
        content = f.read()

    # Поиск по номеру статьи (например, 18.3)
    pattern = rf"\*\*{re.escape(article_number)}\*\*.*?(?=\n\*\*|\Z)"
    match = re.search(pattern, content, re.DOTALL)

    if match:
        embed = discord.Embed(
            title=f"📘 Статья {article_number}",
            description=match.group(0).strip(),
            color=discord.Color.blue()
        )
        await ctx.send(embed=embed)
    else:
        await ctx.send(f"❌ Статья **{article_number}** не найдена в файле.")

@bot.event
async def on_command_error(ctx, error):
    if isinstance(error, commands.CommandNotFound):
        await ctx.send("❌ Команда не найдена! Используйте !помощь")
    elif isinstance(error, commands.MissingPermissions):
        await ctx.send("❌ У вас недостаточно прав для выполнения этой команды!")
    else:
        print(f"Произошла ошибка: {error}")
        await ctx.send("⚠️ Произошла непредвиденная ошибка при выполнении команды")


@tasks.loop(minutes=10.0)
async def check_overdue_loans():
    conn = sqlite3.connect('liberty_country.db')
    conn.row_factory = sqlite3.Row  # Для доступа к колонкам по имени
    c = conn.cursor()

    try:
        c.execute("SELECT * FROM loans WHERE status='active'")
        active_loans = c.fetchall()

        current_time = datetime.now(timezone.utc)

        for loan in active_loans:
            try:
                # Парсим дату из строки
                due_date = datetime.strptime(loan['due_date'], "%d.%m.%Y %H:%M")
                
                if current_time > due_date:
                    citizen_id = loan['citizen_id']
                    amount_left = loan['amount'] - loan['paid_amount']
                    penalty = amount_left * 0.1
                    
                    # Обновляем кредитный рейтинг
                    update_credit_score_by_id(citizen_id, -15)
                    
                    # Помечаем кредит как просроченный
                    c.execute("UPDATE loans SET status='overdue' WHERE id=?", (loan['id'],))
                    
                    # Пытаемся отправить уведомление пользователю
                    user = await bot.fetch_user(loan['discord_id'])
                    try:
                        await user.send(
                            f"⚠️ ВАШ КРЕДИТ #{loan['id']} ПРОСРОЧЕН!\n"
                            f"• Сумма долга: ${amount_left:.2f}\n"
                            f"• Штраф: ${penalty:.2f}\n"
                            f"• Кредитный рейтинг снижен на 15 пунктов"
                        )
                    except discord.Forbidden:
                        print(f"Не удалось отправить сообщение пользователю {loan['discord_id']}")
                    except discord.HTTPException as e:
                        print(f"Ошибка при отправке сообщения: {e}")
            
            except Exception as e:
                print(f"Ошибка при обработке кредита {loan.get('id', 'unknown')}: {e}")
                continue
        
        conn.commit()
    
    finally:
        conn.close()


from discord.ext import tasks
import sqlite3

import asyncio

@tasks.loop(hours=24)
async def business_income():
    await asyncio.sleep(5)  # пауза перед выполнением

    try:
        conn = sqlite3.connect('liberty_country.db', timeout=10)
        conn.row_factory = sqlite3.Row
        c = conn.cursor()

        c.execute("SELECT * FROM businesses WHERE owner_id IS NOT NULL")
        businesses = c.fetchall()

        for business in businesses:
            income = business['income']
            owner_id = business['owner_id']
            business_id = business['id']

            # Начисляем доход владельцу
            c.execute("UPDATE citizens SET bank = bank + ? WHERE id = ?", (income, owner_id))

            # Обновляем дату последнего начисления
            today = datetime.now(timezone.utc).strftime("%Y-%m-%d %H:%M:%S")
            c.execute("UPDATE businesses SET last_income_date = ? WHERE id = ?", (today, business_id))

            # Логируем налог
            tax_amount = int(income * 0.1)
            timestamp = datetime.now(timezone.utc).strftime("%Y-%m-%d %H:%M:%S")
            c.execute('''
                INSERT INTO taxes (citizen_id, type, amount, date)
                VALUES (?, ?, ?, ?)
            ''', (owner_id, "бизнес", tax_amount, timestamp))

        conn.commit()

    except sqlite3.OperationalError as e:
        print(f"❌ Ошибка SQLite в business_income: {e}")
    finally:
        conn.close()


@business_income.before_loop
async def before_business_income():
    await bot.wait_until_ready()


@automatic_income.before_loop
async def before_automatic_income():
    await bot.wait_until_ready()


@check_overdue_loans.before_loop
async def before_check_overdue():
    await bot.wait_until_ready()


# События бота
@bot.event
async def on_member_update(before, after):
    if before.display_name != after.display_name:
        conn = sqlite3.connect('liberty_country.db')
        c = conn.cursor()
        timestamp = datetime.now(timezone.utc).strftime("%Y-%m-%d %H:%M:%S")
        c.execute("INSERT INTO nicknames (user_id, nickname, timestamp) VALUES (?, ?, ?)",
                  (str(after.id), after.display_name, timestamp))
        conn.commit()
        conn.close()
    
    citizen = get_citizen(after.id)
    if citizen and citizen.get('residence'):
        try:
            # Извлекаем первую часть адреса (например, название города)
            residence_parts = citizen['residence'].split(',')
            location = residence_parts[0].strip() if residence_parts else "Unknown"
            
            # Формируем новое имя
            new_nick = f"{citizen['last_name']} | {location}"
            
            # Проверяем, нужно ли менять ник
            if new_nick != after.display_name:
                # Пытаемся изменить ник
                await after.edit(nick=new_nick)
        except Exception as e:
            # Логируем ошибку вместо игнорирования
            print(f"Ошибка при изменении ника пользователя {after.id}: {e}")


# —— ВСТАВИТЬ ЗДЕСЬ перед on_ready() ——
@tasks.loop(hours=24)
async def property_tax_collection():
    conn = sqlite3.connect('liberty_country.db');
    c = conn.cursor()
    c.execute("SELECT owner_id,price FROM houses WHERE status='owned'")
    for owner, price in c.fetchall():
        tax = int(price * 0.001)  # 0.1% в день
        add_tax(owner, 'house_tax', tax)
    conn.commit();
    conn.close()




@tasks.loop(hours=1)
async def business_income_hotels():
    try:
        with sqlite3.connect("liberty_country.db") as conn:
            c = conn.cursor()
            c.execute("UPDATE businesses SET income = income + 1000 WHERE type = 'отель'")
            conn.commit()
    except sqlite3.OperationalError as e:
        print(f"❌ Ошибка БД: {e}")

@tasks.loop(hours=24)
async def business_income_all():
    conn = sqlite3.connect('liberty_country.db')
    c = conn.cursor()
    c.execute("SELECT business_id, owner_id, income FROM businesses")
    for bid, owner, base in c.fetchall():
        c.execute("SELECT SUM(salary) FROM business_employees WHERE business_id=?", (bid,))
        payroll = c.fetchone()[0] or 0
        net = max(0, base - int(payroll * 0.5))  # 50% на зарплаты
        p_tax = int(base * 0.05)  # 5% налог на имущество
        # начисляем владельцу
        c.execute("UPDATE citizens SET bank = bank + ? WHERE id=?", (net, owner))
        add_tax(owner, 'business_prop_tax', p_tax)
        c.execute("UPDATE businesses SET last_income_date=? WHERE business_id=?",
                  (datetime.now(timezone.utc).strftime("%Y-%m-%d %H:%M:%S"), bid))
    conn.commit()
    conn.close()


@bot.listen("on_command")
async def audit_all_commands(ctx):
    await log_audit(bot, f"📥 Команда `{ctx.command}` от пользователя {ctx.author.mention} в канале {ctx.channel.mention}")


@bot.event
async def on_ready():
    print(f'Бот {bot.user.name} готов к работе!')

    try:
        bot.add_view(PassportView())  # Паспорт
        bot.add_view(MDTView())       # MDT
        for faction in ['LCPD', 'LCSD', 'LAFD', 'DOJ']:
            bot.add_view(JobApplicationView(faction))
        print("✅ Все View'ы успешно добавлены.")
    except Exception as e:
        print(f"❌ Ошибка при добавлении View: {e}")

    # Фоновые задачи
    automatic_income.start()
    check_overdue_loans.start()
    check_hotel_expiration.start()
    business_income.start()
    print("⏳ Фоновые задачи запущены.")


init_db()

# === Запуск бота ===
# Загружаем музыкальный модуль и синхронизируем слеш‑команды перед запуском.
async def _lc_setup_hook():
    """
    Пользовательский хук setup для загрузки музыкального модуля и синхронизации слеш‑команд.
    Вызывается автоматически Discord.py перед on_ready.
    """
    try:
        await bot.load_extension("cogs.music_power")
    except Exception as e:
        print("Failed to load music_power cog:", e)
    try:
        await bot.tree.sync()
    except Exception as e:
        print("Failed to sync slash commands:", e)

bot.setup_hook = _lc_setup_hook


def has_passport(user_id):
    conn = sqlite3.connect("main.db")
    conn.row_factory = sqlite3.Row
    c = conn.cursor()
    c.execute("SELECT * FROM passports WHERE user_id = ?", (user_id,))
    result = c.fetchone()
    conn.close()
    return result is not None


@bot.hybrid_command()
async def паспорт(ctx):
    user_id = ctx.author.id
    if not has_passport(user_id):
        await ctx.send("📄 У вас нет паспорта! Оформите его через команду `/получить_паспорт`.")
    else:
        await ctx.send("📄 Ваш паспорт уже оформлен!")


# Получаем токен из переменной окружения DISCORD_TOKEN. Если не задан, бот не будет запущен.
token = os.getenv("DISCORD_TOKEN", "").strip()
if not token:
    print("⚠️ Переменная окружения DISCORD_TOKEN не задана. Бот не запущен.")
else:
    bot.run(token)
